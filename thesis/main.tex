\documentclass[twoside, 12pt]{article}
\usepackage{xdipp}
\usepackage{listings}
\usepackage{caption}
\usepackage{float}
\english
\pismo{Latin Modern}


\lstdefinestyle{mystyle}{
    % numbers=left,
    % numbersep=5pt,
    showspaces=false,
    tabsize=2,
    frame=single,
}
\lstset{style=mystyle}

\begin{document}
\titul{MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947}{Dmitrii Titarenko}{Ing. Jan Kolomazník, Ph.D.}{Brno 2025}

\podekovani{I would like to express my gratitude to everyone who contributed to completion of 
this thesis.\\ I would like to thank my thesis supervisor, Ing. Jan Kolomazník, Ph.D. , for 
his guidance and support. Furthermore, I express my gratitude to Zbynek Fedra Ph.D. for 
guiding me during the creation of this thesis.\\
I am also very grateful to all the professors in the Department of Informatics at Mendel 
University for their teaching, openness, and constant support throughout my study.\\
A big thank you to family members and friends for their support and encouragement.\\
Finally, I express gratitude to the people who directly or indirectly contributed to the 
creation of this work. To those who came before me and on whose shoulders I stand.}
\prohlasenimuz{Brno ~03.08.2025}

\abstrakt{Titarenko, D. MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947.
Bachelor thesis. Brno, 2025.}{Práce zkoumá podporu MicroPython na Zephyr RTOS s využitím 
vývojové desky FRDM-MCXN947 od NXP. Samo o sobe Zephyr RTOS poskytuje širokou podporu a 
snadno použitelné API pro mnoho embedded zařízení a jejích periferii, ale podpora MicroPython 
je stále limitovaná a nekonzistentní s MicroPython porty vyvíjený pro jíná zařízení. Práce 
analyzuje součastné limity MicroPython na Zephyr RTOS a vybírá funkčnost pro implementaci. 
Implementace zahrnuje inicializaci vývojovýho prostředí pro Zephyr a MicroPython, které bude 
upravené pro FRDM-MCXN947, provádění funkčního testování periferii vývojové desky v vývojovém 
prostředí pro Zephyr a MicroPython a porovnáním kompatibility nativného poru a Zephyr portu 
MicroPython.}
\klslova{MicroPython, závěrečná práce, Zephyr RTOS, FRDM-MCXN947}

\abstract{Titarenko, D. MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947. Bachelor 
thesis. Brno, 2025.}{This thesis explores MicroPython support on Zephyr RTOS using the NXP 
FRDM-MCXN947 development board. Zephyr RTOS itself provides extended support and easy-to-use 
APIs to many embedded devices and their peripherals, but the support of MicroPython remains 
limited and not consistent with MicroPython ports developed for other devices. This work 
analyzes the current limitations of MicroPython on Zephyr RTOS and selects specific 
functionality for implementation. The implementation involves initializing Zephyr and 
MicroPython development environments adjusted to FRDM-MCXN947, conducting functional testing 
of the development board peripherals with Zephyr and MicroPython environment, and comparing 
the compatibility of native and Zephyr ports of MicroPython.}
\keywords{MicroPython, thesis, Zephyr RTOS, FRDM-MCXN947}

\obsah

\listoffigures

\lstlistoflistings

\kapitola{Introduction}
The world of microcontrollers and embedded devices continues to grow, and such devices become 
more common with every day. Even though they are seldom noticeable we more often might find 
ourselves surrounded by them. From home appliances, to cars, to factory machines to city-wide 
networks embedded devices reach wide and deep in our lives.

But with the growing count of embedded devices grows complexity of functions they implement. 
Hence arises a need for Operating Systems(OSs) to manage sets of complex programs and provide 
a layer of abstraction to ease development in such constrain but demanding environments.

To cover demand of an Operating System in embedded devices the Zephyr Real Time Operating 
System (RTOS) was created. Zephyr RTOS is an open-source operating system with build-in 
security and optimization for resource limited devices. Zephyr kernel supports ARM, Intel 
x86, ARC, RISC-V, Nios II, Tensilica Xtensa and large number of development boards, among 
others NXPs FRDM-MCXN947. ALso Zephyr has rich API that allows developers to write high-level 
code for embedded devices.

Writing software for embedded devices is still a complex task regardless of what underlying 
technologies are used. Writing it in a language such as C adding an additional complexity
due to need of managing program memory allocation and deallocation by hand.
Leaving unhandled memory sector could lead to memory leaks or worse opens an opportunity for
an attacker to execute malicious code on an embedded device. The consequences of such problems
become much grater when occurring in the embedded world. MicroPython is an optimized subset 
of Python 3 programming language for embedded devices. It aims to ease writing software by 
managing memory using its garbage collector system, using easy to read Python-like syntax and 
providing various modules to enable work with different peripherals. Additionally, 
MicroPython allows for code portability, meaning that code written for FRDM-MCXN947
could be ported and ran on ESP32 with minimal updates to code. 

But MicroPython does not 
support every single device straightaway -- ported versions of MicroPython are submitted to 
the MicroPython repository, by a manufacturer or an enthusiasts. Later submitted port will be 
reviewed and tested by MicroPython maintainers, which is a lengthy process, for example 
MicroPython port for Zephyr was under review for 2 years.

By combining Zephyr RTOS and MicroPython in one technological stack the best of both 
technologies could be utilized. Potential exists for developers to write highly readable,
easy-to-understand and efficient code with MicroPython that make use of various hardware 
support introduced by Zephyr RTOS. Yet the state of this development environment is not yet 
firm and have plenty of rough edges and unapparent problems that could arise during the 
process of software development.

The aim of this thesis is to construct a method for configuring the development environment 
for MicroPython, Zephyr RTOS and FRDM-MCXN947 development board, provide insight of 
compatibility challenges of both platforms and propose potential solutions for extending 
MicroPython port to Zephyr RTOS. The finding of this thesis will contribute to understanding 
of the state of both platforms and their integration, informing future developers and increasing usability of MicroPython and Zephyr.

\sekce{Goal of this thesis}
Goal of the thesis is to establish development environment and workflow for developing 
applications for embedded devices with the MicroPython Zephyr port. This work could be used
in future to ease start of application development and as a reference.

\kapitola{Background}
This chapter introduces the reader to an information about Zephyr RTOS, MicroPython and FRDM-
MCXN947 board that is needed for understanding this thesis.

\sekce{Zephyr RTOS}
Zephyr is an Operation System designed for resource-constrained and embedded 
system from simple sensors to smart industrial embedded solutions with emphasis on safety. It 
supports a broad list 
of embedded devices, development boards and peripherals. Zephyr offers extensive number of 
features and services including multi-threading, inter-thread data passing, inter-thread 
synchronization, dynamic memory allocation, interrupt service, power management, networking, file system.
Zephyr project is open-source, distributed under Apache 2.0 license and was created under 
Linux Foundation organization.\cite{zephyr1}

\obrazek
\vlozobr{images/security-zephyr-system-architecture}{0.5}
\endobr{Zephyr System Architecture \obrzdroj{\cite{zephyr_architecture}}}

\podsekce{West}
West is a part of Zephyr's tool-chain used for building and configuring. West can initiate
Zephyr workspace from official upstream repository, update or change version of a local
Zephyr workspace to any version in official repository, build Zephyr application from source,
flash built application to a board.\cite{zephyr_west}

\podsekce{Kconfig}
Kconfig is Zephyr's kernel, peripheral drivers and subsystems configuration system that allow 
to configure Zephyr at a build time. Kconfig goal is to enable configuration without 
introducing changes to the source
code.

The initial board configuration can be found in \textbf{<board>\_defconfig} files. For
example configuration file for FRDM-MCXN947 is located at \textbf{boards/nxp/frdm\_mcxn947/
frdm\_mcxn947\_mcxn947\_cpu0\_defconfig}. The board configuration for NXPs' FRDM-MCXN947
is as follows:
\begin{lstlisting}[caption=FRDM-MCXN947 Kconfig configuration]
CONFIG_CONSOLE=y
CONFIG_UART_CONSOLE=y
CONFIG_SERIAL=y
CONFIG_UART_INTERRUPT_DRIVEN=y
CONFIG_GPIO=y
CONFIG_PINCTRL=y
CONFIG_ARM_MPU=y
CONFIG_HW_STACK_PROTECTION=y
CONFIG_TRUSTED_EXECUTION_SECURE=y
\end{lstlisting}

Kconfig values can be set to a \textbf{<board>\_defconfig} files, temporarily with terminal
graphical interfaces or with a \textbf{prj.conf} file at application level which overrides
the initial configuration during application build.\cite{zephyr_kconfig}

\podsekce{Devicetree}
Devicetree is a data structure to describe hardware. It is a community driven standard
that is heavily used in Zephyr project. In Zephyr devicetrees are usually build inherently 
meaning that for example FRDM-MCXN947 has a devicetree configuration \textbf{board/nxp/frdm\_mcxn947/frdm\_mcxn947\_mcxn947\_cpu0.dts}
which mainly enables peripheral devices, but includes FRDM-MCXN947 specific configuration 
from \textbf{frdm\_mcxn947.dtsi} (include file), which in turn includes 
\textbf{frdm\_mcxn947-pinctrl.dtsi} file that mostly defines pinmux groups. Additionally the 
\textbf{frdm\_mcxn947\_mcxn947\_cpu0.dts} includes \textbf{nxp\_mcxn94x.dtsi} file that 
defines memory ranges for SRAM, FLEXSPI and peripherals and includes 
\textbf{nxp\_mcxn94x\_common.dtsi} include file where most of devices including CPU, GPIO, 
CTIMER and others are defined and assigned memory ranges.\cite{devicetree_spec}

Same as Kconfig Devicetrees can be overwritten or have some specific devices configured 
differently with \textit{overlay} files, which as well needs to be placed in build directory, 
from there \textit{west} tool will use it to edit the Devicetree configuration.

\sekce{MicroPython}
MicroPython is an open-source project founded by Damien George. MicroPython is an implementation of the Python programming 
language that 
is optimized to be run on embedded and resource constraint devices. It implements 
the entire Python 3.4 syntax with some selected features from the later versions such as
\textit{async/await} from Python 3.5 , additionally on par with Python it uses garbage 
collection system for memory management. MicroPython final build include a compiler that 
compiles MicroPython code to bytecode and an runtime interpreter of the compiled bytecode.
Programs could be written directly to the MicroPython REPL(Read–eval–print loop) or be loaded
onto MicroPython host device with use of serial connection and utility programs like \textit{ampy}.


MicroPython's core development is focused on implementing and maintaining core features
of the MicroPython like Python language features, libraries, memory management and 
MicroPython interpreter. The responsibility for adapting and porting MicroPython to different
platforms lies on the community around it. Every MicroPython port introduces required 
adaptations and addresses hardware features and limitations of its platform. Consequently,
MicroPython support is not linear on all platforms, because some might lack the necessary
configuration for enabling a part of functionality or even lack reimplementation of a number of core libraries. Additionally, the slow pace of adding to source code features for various platforms 
created by the community means that
even fully functional and tested ports or features might wait for months before being reviewed.
Despite all of this, there are already many supported devices and architectures that 
MicroPython can run on. MicroPyton has additional support to be run on
operating system Zephyr RTOS and on OSes from UNIX family, as well as experimental Windows 
port.

MicroPython remains in beta-stage, hence it is a subject to possible API and code-base changes in the future.\cite{mpy_book}

\sekce{FRDM-MCXN947}
The FRDM-MCXN947 is a low-cost development board designed by NXP semiconductors. FRDM-MCXN947 
integrates Dual Arm
Cortex-M33 microcontroller, a neural processing unit, P3T1755DP I3C temperature sensor, 
TJA1057GTK/3Z CAN PHY, Ethernet PHY, SDHC circuit, RGB LED, touch pad, high-speed USB, MCU-Link debuger,
push buttons and has an option to be extended with external devices.
\cite{mcxn947_manual}

\obrazek
\vlozobr{images/frdm-diagram}{0.35}
\endobr{FRDM-MCXN947 Block diagram \obrzdroj{\cite{mcxn947_web}}}

\podsekce{Signal Multiplexing}
FRDM-MCXN947 enables use of several functions for different pins by utilizing Signal 
Multiplexing. For example pin \textbf{P0\_10} which is an red RGB pin can use \textbf{GPIO} 
functionality directly, \textbf{FLEXCOMM} by utilizing \textbf{FC0\_P6} FLEXCOMM device,
\textbf{CTIMER} by utilizing \textbf{CT0\_MAT0} CTIMER device, and \textbf{FLEXIO} 
functionality by utilizing \textbf{FLEXIO0\_D2} device.

Only one function can be used at a time on a pin and only one pin can be assigned to a 
peripheral device. \cite{mcx_manual} 

\podsekce{LinkServer}
LinkServer is an NXP command-line utility that provides  target flashing capabilities and 
firmware updates for FRDM-MCXN947. This is typically used as a backend for flashing FRDM-MCXN947 in \textit{west} utility. \cite{link_server}

\sekce{MicroPython port to Zephyr}
While Zephyr RTOS provides a feature-packed and expandable development and system to be used
in embedded world standard development in C can be time consuming. MicroPython's Zephyr port
brings advantages of both MicroPython and Zephyr to single environment, allowing to write
hight-level Python like code and rapidly prototype and debug, while also leveraging hardware 
agnostic Zephyr APIs and wide support of
different embedded devices and their peripherals.

But despite growth in support between Zephyr and MicroPython there are still features that 
lack in the port and issues with coupling of both technologies. For a long time the 
MicroPythons' Zephyr port have been using an older versions of Zephyr and
MicroPython itself. It used MicroPython 1.19.1 and Zephyr 3.1.0 versions which both came out 
in period between May and June 2022 until September 2024. In September 2022 began work by 
Maureen Helm  to introduce a CI pipeline into MicroPython repository to ease porting 
MicroPython to latest Zephyr release. From this work emerged last MicroPython Zephyr port 
version based on MicroPython 1.24.0 and Zephyr 3.7.0.

And though MicroPython Zephyr port
already supports the MicroPython modules like socket, time, math, machine and other are 
implemented and usable in the final MicroPython build they may lack support of some 
sub-modules like machine's PWM sub-module or functionality of modules and sub-modules like
not yet implemented features of machine's I2C sub-module that do not have ability to set clock and data lines.

A MicroPython's Zephyr port is built in a same way any Zephyr application is built. A 
\textit{west} utility is used and MicroPython port to Zephyr source code as a build target.
The final build could be configured and some features or peripherals could be activated or 
deactivated with \textit{Kconfig} and a final devicetree be overwritten with devicetree 
\textit{overlays}. Then the result binary file is fleshed to a target board with \textit{west}
utility.

\sekce{Summary}
For utilizing MciroPython Zephyr port on FRDM-MCXN947 board it is needed to build MicroPython 
port as a Zephyr application, and then flash this application onto the development board, 
both operations are made with use of Zephyr's \textit{west} utility. Program flashing is made using \textit{LinkServer}.

Pre-build configuration is possible using \textit{Kconfig}, for setting what peripherals and sub-system are to be enabled or disable, and \textit{Devicetree}, for creating or updating a structured description of the underling hardware.

FRDM-MCXN947 is a programmable and extendable development board with many devices, 
peripherals and systems available.

\kapitola{Methodology}
\sekce{Introduction}
This chapter introduces the reader to the set of tools used in this thesis and outlines a 
methodological approach. First Zephyr and MicroPython development environments will be setup 
and tested, following with their integration for building MicroPython's Zephyr port. Next the
MicroPython's Zephyr port will be extended with use of configuration and additional code to 
bring it  closer to the level of native port support. Finally, the thesis will conclude by 
building a web server that will run on FRDM-MCXN947  utilizing MicroPython's Zephyr port.

\sekce{Zephyr development environment setup}
This section will detail the process of setting up a development environment for working with
Zephyr RTOS. The setup will be broken into several steps to provide clear and easy-to-follow 
instructions to the reader.

Firstly, the prerequisites and dependencies would be introduced along with the installation 
process. The reader will be briefed on purpose of the key dependencies. After the 
necessary preparation the Zephyr Software Development Kit (SDK) and source code will be obtained. For the Zephyr SDK two methods for obtaining it
will be presented and discussed. Then the \textit{west} tool will be described in detail and
it's abilities for managing the project will be discussed. Next, the installation and use of 
the \textit{LinkServer} utility and its alternatives will be discussed. Finally, the 
development setup will be verified with a functional test on a FRDM-MCXN947 board and test 
prerequisites discussed.

\sekce{Use of MicroPython on FRDM-MCXN947}
This section will describe how to use MicroPython on FRDM-MCXN947 board.The 
\textit{LinkServer} utility will be used and aspects of it will be discussed.

The section will begin with an explanation on what are the possibilities to obtain 
MicroPython binary. Particularly, the current process of that takes place to obtain 
MicroPython binary working on FRDM-MCXN947 will be shown. After obtaining the binary it will 
be shown how to load it to the board. The section will conclude with a functional test of 
MicroPython possibilities.  

\sekce{MicroPython port to Zephyr RTOS}
The section will present an approach on how to setup and start using MicroPython's Zephyr 
port.

It will start with setting up a development environment for MicroPython. After this process 
of building a MicroPython Zephyr port will be shown with ways of how to influence the final 
build. The section will conclude with an illustrative program.

\sekce{Comparing native and Zephyr ports}
This section will compare two MicroPython builds the NXP native MicroPython implementation 
and Zephyr port focusing on availability and functionality of the built-in modules. The 
goal of this  section is to identify what modules are supported by each implementation and to 
highlight the missing features. In process how modules are getting added to the MicroPython's Zephyr port will be explored, which will allow to extend modules support in feature section.

\sekce{Extending Zephyr Port functionality}
This section will try to extend the MicroPython's Zephyr port with modules. 

First, list of modules available to use in MicroPython's Zephyr port will be extended by 
methods explored in previous section. Next, a community extension will be added to bring a 
PWM support and the board build will be configured with \textit{Kconfig} and 
\textit{Devicetree} for PWM to work. Finally, how a new module
could be created, and how to add this module to the MicroPython build.

\sekce{Creating an HTTP server of FRDM-MCXN947 with MicroPython's Zephyr port}
In this section the process and steps to create a web server for controlling the
FRDM-MCXN947 board will be discussed. Zephyr's strong networking stack will be utilized for 
local network IP configuration as well as data transition and reception. The necessary 
configuration will be explained along with the code for the server.

\kapitola{Implementation}
\sekce{Introduction}
This chapter describes configuration and development of the MicoPython's Zephyr port itself 
as of the web server built utilizing this port. The main outcome of this thesis is a MicroPython-based web server running on a FRDM-MCXN947 board that host Zephyr RTOS.

The first part of this thesis is focusing on describing the setup and a necessary 
configuration of the development environment for building and running MicroPython on Zephyr 
RTOS. Next the MicroPython port for Zephyr is compared against a MicroPython port for FRDM-
MCXN947  developed by NXP. The MicroPython's Zephyr port then is synchronized with the port 
by NXP in terms of capabilities and modules supported.

This chapter concludes with implementation of a web server that demonstraites the capabilities of the extended MicroPython's Zephyr port.

\sekce{Zephyr development environment setup}
\podsekce{Installing Zephyr and it's dependencies}
Before starting to setting up the development environment for Zephyr the needed dependencies 
need to be obtained. Those include :
\begin{itemize}
    \item \textit{git} -- Zephyr's \textit{west} tool uses \textit{git} as a backend
    \item \textit{cmake} -- Zephyr use \textit{cmake} as it's build system for configuration 
    and build files generation.
    \item \textit{ninja} -- is a performance based build system that is used by CMake for building a project.
    \item \textit{make} -- some tools expecting or fall back to Make.
    \item \textit{gperf} -- GNU utility for fast hash generation used in Zephyr for lookup. 
    \item \textit{ccache} -- an utility that speeds up compilation time by caching previous compilation.  
    \item \textit{dtc} -- compiles \textit{Devicetree} files.
    \item \textit{xz} -- is a set of data compression utilities used for decompressing Zephyr SDK.
    \item \textit{wget} -- used to download Zephyr SDK.
    \item \textit{python-pip} -- used to install Zephyr's \textit{west} tool.
    \item \textit{python-setuptools} -- Python build helper package.
    \item \textit{python-wheel} -- Python build helper package.
    \item \textit{dfu-util} -- implementation of Direct Firmware Update and is used in Zephyr to flash firmware and programs to a board. 
\end{itemize}

The next step after obtaining all the dependencies is to install the Zephyr SDK. There are
two options of installing Zephyr SDK: using the \textit{west} tool (which is shown at page \pageref{west_sdk_install}) or 
performing a manual installation. To install the SDK in desired installation directory 
execute:
\begin{lstlisting}[caption=Installing Zephyr SDK: obtaining SDK, breaklines=true]
wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.0/zephyr-sdk-0.17.0_linux-x86_64.tar.xz
wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.0/sha256.sum | shasum --check --ignore-missing
\end{lstlisting}

These commands download the archived Zephyr SDK and verify it's integrity using SHA-256 
checksum. The download \textit{URL} could be altered to download the SDK for other operating 
systems like \textit{Windows, Mac Os} by changing the system name to \textit{windows}(windows 
SDK version uses 7z archive format and does not have ARM variant) or \textit{macos} and for 
ARM processors by changing architecture name to \textit{aarch64}.

The content of the downloaded archive is the extracted file and the \textit{ setup} script is 
run. Additionally for Linux systems it is recommend to install \textit{udev} rules, which 
will allow to flash boards with Zephyr as a regular user:
\begin{lstlisting}[caption=Installing udev rules,breaklines=true]
sudo cp ~/zephyr-sdk-0.17.0/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d
sudo udevadm control --reload
\end{lstlisting}

For building and working with Zephyr applications it is required to obtain Zephyr source code 
and configure a Python virtual environment. First, Python virtual environment \textit{venv} 
needs to be installed. In the preferred working directory then the new \textit{venv} 
environment is initialized and activated:
\begin{lstlisting}[caption=Creating and activating Python venv environment]
python3 -m venv ~/zephyrproject/.venv
source ~/zephyrproject/.venv/bin/activate
\end{lstlisting}

Zephyr uses it's tool \textit{west} for to manage it's source code, dependencies and to build 
and flash applications. \textit{West} could be installed to \textit{venv} environment using:
\begin{lstlisting}[caption=Installing Zephyr's West tool]
pip install west
\end{lstlisting}

With \textit{west} installed it could be used to obtain Zephyr's source code:
\begin{lstlisting}[caption=Obtaining Zephyr's source code]
west init
west update
\end{lstlisting}

This command registers the current Zephyr installation as a CMake config package in the CMake user package registry.\cite{zephyr_cmake_commands}
\begin{lstlisting}
west zephyr-export
\end{lstlisting}

At this point Zephyr's SDK could be installed if it was not already using \textit{west}: 
\begin{lstlisting}[caption=Installing Zephyr SDK using West]
west sdk install
\end{lstlisting}\label{west_sdk_install}

\podsekce{Installing LinkServer}
To flash application to FRDM-MCXN947 board Zephyr uses the NXP's \textit{LinkServer} utility.
The installation files for different Operating systems are available on the web page of the \textit{LinkServer} utility.\cite{link_server}

Also J-Link could be used as an alternative though it needs additional hardware peripherals.  \cite{zephyr_mcxn947}

\podsekce{Configuring serial port}
This step is not required for the development and correct work with Zephyr, but it's useful 
to have a capability to see board logs and to interact with the board through a command line 
interface from the development environment. For Linux and Mac OS \textit{minicom}\cite{jayantilal_hc05} and 
\textit{screen}\cite{gnu_screen} open-source utilities could be used, for Windows \textit{PuTTY} serial port 
capabilities could be utilized. 

For establishing serial communication with a FRDM-MCXN947 board the following configuration parameters should be used\cite{mcxn947_getting_started}:
\begin{lstlisting}[caption=Serial port configuration]
Baud rate: 115200
Data size: 8
Parity: None
Stop bit: 1
\end{lstlisting}

\podsekce{Building and flashing a program to FRDM-MCXN947}
In this subsection to carry out testing of the development environment and demonstrate the
flashing and building process of Zephyr applications, a Zephyr-provided sample program will 
be built.

To build the sample application \textit{west} utility is used:
\begin{lstlisting}[caption=Building the Blinky Program, breaklines=true]
west build -p always -b frdm_mcxn947/mcxn947/cpu0 samples/basic/blinky
\end{lstlisting}

where arguments \textit{-p always} makes a pristine build \cite{zehpyr_west_building}, 
\textit{-b frdm\_mcxn947/mcxn947/cpu0} specifies the target(\textit{cpu0} is specified 
because only it can be targeted standalone, second core is enabled after configuring 
\cite{zephyr_mcxn947}) and \textit{samples/basic/blinky} specifies program to build.

The built binary then can be flashed to the board using \textit{west} and \textit{LinkServer}. For this, board need to be connected with USB-C via \textit{J-17} port.
Flashing is run with:
\begin{lstlisting}[caption=Flashin a program]
west flash
\end{lstlisting}
After flashing, the red led will start to blink with a one-second period.

With the successful build and flashing of the program to the FRDM-MCXN947 board, it is 
verified that the Zephyr development environment functions correctly and now prepared for 
further development.

\sekce{Use of MicroPython on FRDM-MCXN947}
\podsekce{Installing MicroPython on FRDM-MCXN947}
In this section the process of installing MicroPython interpreter on FRDM-MCXN947 board is 
described.
    
    There are many boards that have direct MicroPython ports or support through their
architecture\cite{mpy_boards}, but FRDM-MCXN947 is not among them due to the port made by NXP 
developers not yet being reviewed and merged into the main MicroPython repository. Instead 
the MicroPyhton binary must be obtained through NXP's article\cite{mcxn947_mpy_bin} or 
compiled from source code of the development branch from NXP with port to FRDM-MCXN947.
For sake of time saving the MicroPython binary version used in this thesis was downloaded 
from the said NXP article.

Before proceeding with flashing the binary to the target board the \textit{LinkServer} 
utility must be installed on the host computer and the board itself is connected to the host 
computer with USB-C via \textit{J-17} port.

To ensure the board has no prior binaries install the following command is used:
\begin{lstlisting}[caption=LinkServer erase]
LinkServer flash MCXN947:FRDM-MCXN947 erase
\end{lstlisting}

To flash the binary to the FRDM-MCXN947 this command is used:
\begin{lstlisting}[caption=LinkServer flash,breaklines=true]
LinkServer flash MCXN947:FRDM-MCXN947 load firmware.bin  --addr 0
\end{lstlisting}
After the flash process has ended, serial port connection could be made to the board, which will reveal REPL environment for code execution.

\obrazek
\vlozobr{images/nxp_mpy_flash_minicom}{0.55}
\endobr{MicroPython REPL environment on the FRDM-MCXN947 board, access via the \textit{minicom} utility}

\podsekce{Writing and flashing MicroPython programs}
There are two common approaches to writing programs for MicroPython: either by entering the 
code directly to REPL, which allows fast prototyping and modules or periphery testing, or to 
load the python code onto the board using utilities like \textit{rshell} or \textit{ampy}. 

Both \textit{ampy} and \textit{rshell} utilities are installed via Python's \textit{pip} 
package manager and to the Python virtual environment.

To test MicroPython capability and program loading to the board with MicroPython the 
following code for reading temperature data from the \textit{P3T1755} temperature sensor on 
the FRDM-MCXN947 board:
\begin{lstlisting}[caption=Read tempreture data from P3T1755 sensor using MicroPython, breaklines=true]
import machine, time

P3T_ADDR = 72

i2c = machine.I2C(5, scl=machine.Pin('P1_17'), sda=machine.Pin('P1_16'))

class P3T1755:
    def __init__(self, i2c, addr):
        self.addr = addr
        self.i2c = i2c

        self.i2c.writeto(self.addr, b'\x00')

    def read(self):
        temp_raw = i2c.readfrom(self.addr, 2)
        temp_converted = ((temp_raw[0] << 4) | (temp_raw[1] >> 4)) * 0.0625
        return temp_converted

ts = P3T1755(i2c, P3T_ADDR)

while(True):
    print("Temperature: {:.2f} Deg.C".format(ts.read()))
    time.sleep_ms(100)
\end{lstlisting}

To load and run this code on the board with MicroPython the code must be saved to a file and 
loaded with:
\begin{lstlisting}[caption=Loading a program to FRDM-MCXN947 board with MicroPython using ampy utility, breaklines=true]
ampy --port /dev/ttyACM0 run you_micropython_code.py
\end{lstlisting}

The output from the board will be shown in the console the program was loaded from, to only 
load the program the \textit{--no-output} parameter could be passed to the \textit{ampy} 
utility.

\obrazek
\vlozobr{images/mpy_tempreture_test}{0.80}
\endobr{Output of the FRDM-MCXN947 board after loading temperature reading program}

It is now verified that the MicroPython port by NXP works correctly on the FRDM-MCXN947 board.


\sekce{MicroPython port to Zephyr RTOS}
\podsekce{Setup of the MicroPython Zephyr port}
This section details the process of building and running MicroPython's Zephyr port on FRDM-
MCXN947 development board. To begin firs the MicroPython source code should be obtained, 
either from \textit{git} repository or as a archived file from the project's web.

Before proceeding with the build creating a Python virtual environment in the Zephyr 
installation directory if not done yet.

The build of the MicroPython's Zephyr port is done from Zephyr development environment using \textit{west} utility:
\begin{lstlisting}[caption=Building MicroPython's Zephyr port, breaklines=true]
west build -p always -b frdm_mcxn947/mcxn947/cpu0 ~/micropython/ports/zephyr
\end{lstlisting}
Where the target program is a path to \textit{/ports/zephyr} directory in MicroPython's source
code.

During the initial build the following error may occure:
\begin{lstlisting}[caption=Error building MicroPython's Zephyr port,breaklines=true]
/micropython/ports/zephyr/modzephyr.c:52:5: error: too few arguments to function 'thread_analyzer_print'
   52 |     thread_analyzer_print();
      |     ^~~~~~~~~~~~~~~~~~~~~
\end{lstlisting}

The issue is due to an API mismatch introduced in newer versions of Zephyr. To solve this, the
Zephyr version should be lowered to 3.7.0. This could be done using \textit{git} and it's \textit{checkout} command to switch to \textit{v3.7-branch} branch.

After switching to an older branch the building process finishes without further errors and 
the resulting binary could be flashed to the FRDM-MCXN947 board using \textit{west} utility.

After flash with the help of serial port program a similar to NXP's MicroPython port REPL environment is seen with additional information on hosting OS.

\obrazek
\vlozobr{images/mpy_zephyr_build_minicom}{0.7}
\endobr{MicroPython's Zpehyr port REPL environment on the FRDM-MCXN947 board, access via the \textit{minicom} utility}

The same applies to program loading as with NXP's MicroPython port. Programs can be either 
written directly into REPL environment or uploaded using tools such as \textit{ampy}.

To verify the functionality of the built MicroPython's Zephyr port and compare it to NXP's 
port a simple program was developed, which utilizes \textit{GPIO} pins of green and red on 
board LEDs to switch between low and high voltage.

\begin{lstlisting}[caption=Led program for MicroPython's Zephyr port, breaklines=true]
import time
from machine import Pin

red = Pin(("gpio0", 10), Pin.OUT)
red.value(1)
green = Pin(("gpio0", 27), Pin.OUT)
green.value(1)

while True:
    green.value(0)
    time.sleep(1.5)
    red.value(0)
    time.sleep(1.5)
    green.value(1)
    time.sleep(1.5)
    red.value(1)
\end{lstlisting}

After loading the program to the FRDM-MCXN947 board the red and green LEDs will be periodically set to high and low voltage.

Note how the program needs to refer to a pin in the MicroPython's Zephyr port as a tuple 
while in NXP's port it uses a string name of the pin. MicroPython's Zephyr port use 
definition of the board and periphery from \textit{Devicetree} files where \textit{gpio0} is 
a peripheral which exposes various pins, such as pins 10 and 27, each configured for specific 
functions.

\sekce{Comparing native and Zephyr ports}
\podsekce{Modules available on NXP's port}
This section compares module support of NXP's and Zephyr MicroPython ports. The analysis 
includes a list of modules available for both ports. The analysis was made by importing 
modules into the REPL environment and passing them to the \textit{help()} function.

NXP port provides a variety of modules specific for the hardware of the FRDM-MCXN947 board 
and common MicroPython modules. To get a list of supported modules on NXP port 
\textit{help('modules')} command could be used in the REPL environment which returns the 
following list:

\newpage

\begin{lstlisting}[caption=NXP's port modules, breaklines=true]
__main__                asyncio/stream
_asyncio                binascii      
_boot                   builtins      
_onewire                cmath         
array                   collections   
asyncio/__init__        deflate       
asyncio/core            dht           
asyncio/event           ds18x20       
asyncio/funcs           errno         
asyncio/lock            framebuf      
gc                      os
hashlib                 platform
heapq                   random
io                      re
json                    select
machine                 struct
math                    sys
mcx                     time
micropython             uasyncio
onewire                 uctypes
\end{lstlisting}

Modules could also be passed as parameters to the \textit{help()} function to reveal what 
functions does the module have and what constants it defines.

\podsekce{Modules available on Zephyr port}\label{zephyr_mpy_moduels}
In contrast to the NXP's port, running \textit{help('modules')} does not yield the supported 
modules. Instead to get the list of supported modules it is needed to either try to import 
modules and pass them to the \textit{help()} function or to read the source-code of the 
MicroPython's Zephyr port, specifically the \textit{CMakeLists.txt CMake} file where some of 
the imported modules are listed :
\begin{lstlisting}[caption=Zephyr port CMake list, breaklines=true]
set(MICROPY_SOURCE_PORT
    main.c
    help.c
    machine_i2c.c
    machine_spi.c
    machine_pin.c
    modbluetooth_zephyr.c
    modsocket.c
    modzephyr.c
    modzsensor.c
    mphalport.c
    uart_core.c
    zephyr_device.c
    zephyr_storage.c
    mpthreadport.c
)
list(TRANSFORM MICROPY_SOURCE_PORT PREPEND ${MICROPY_PORT_DIR}/)
\end{lstlisting}

Those modules are direct ports of the equivalent Python or MicroPython modules with use of 
Zephyr APIs.

Additionally, MicroPython's Zephyr port contains \textit{prj.conf} file that is passed to 
Zephyr when compiling the port and it hav \textit{CONFIG\_MICROPY\_CONFIGFILE} parameter that
specifies a modules configuration file \textit{mpconfigport.h} :
\begin{lstlisting}[caption=Part of MicroPython's Zephyr port mpconfigport.h module conifguration file, breaklines=true]
...
#define MICROPY_ENABLE_SOURCE_LINE  (1)
#define MICROPY_STACK_CHECK         (1)
#define MICROPY_ENABLE_GC           (1)
#define MICROPY_ENABLE_FINALISER    (MICROPY_VFS)
#define MICROPY_HELPER_REPL         (1)
#define MICROPY_REPL_AUTO_INDENT    (1)
#define MICROPY_KBD_EXCEPTION       (1)
#define MICROPY_PY_ASYNC_AWAIT      (0)
#define MICROPY_PY_BUILTINS_BYTES_HEX (1)
#define MICROPY_PY_BUILTINS_FILTER  (0)
#define MICROPY_PY_BUILTINS_MIN_MAX (0)
#define MICROPY_PY_BUILTINS_PROPERTY (0)
...
\end{lstlisting}

The \textit{mpconfigport.h} file contains a list of C macros\cite{kernighan_c} that act like 
a switch to enable and disable said modules.

An analysis yielded the following list of the supported modules in MicroPython's Zephyr port:
\begin{lstlisting}[caption=Zephyr port modules, breaklines=true]
binascii    hashlib         
builins     machine    
errno       math       
gc          micropython
os          usys
socket      utime
sys         vfs
time        zephyr
zsensor
\end{lstlisting}

\podsekce{Comparing modules availability in two ports}
The table below summarizes the difference in module support between NXP's and Zephyr MicroPython ports:

\begin{table}[H]
\centering
\caption{Difference in module support of NXP's and Zephyr MicroPython ports}
\label{tab:micropython-modules}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|} \hline
\textbf{MicroPython Port to Zephyr} & \textbf{NXP's MicroPython implementation} \\ \hline
& array \\ \hline
& asyncio \\ \hline
binascii & binascii \\ \hline
builtins & builtins \\ \hline
& cmath \\ \hline
& collections \\ \hline
& deflate \\ \hline
& dht \\ \hline
& ds18x20 \\ \hline
errno & errno \\ \hline
& framebuf \\ \hline
gc & gc \\ \hline
hashlib & hashlib \\ \hline
& heapq \\ \hline
& io \\ \hline
& json \\ \hline
machine & machine \\ \hline
math & math \\ \hline
& mcx \\ \hline
micropython & micropython \\ \hline
& onewire \\ \hline
os & os \\ \hline
& platform \\ \hline
& random \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\ContinuedFloat
\caption*{(continued)}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|} \hline
\textbf{MicroPython Port to Zephyr} & \textbf{NXP's MicroPython implementation} \\ \hline
& re \\ \hline
& select \\ \hline
& struct \\ \hline
socket & \\ \hline
sys & sys \\ \hline
time & time \\ \hline
& uasyncio \\ \hline
& uctypes \\ \hline
usys & usys \\ \hline
utime & utime \\ \hline
vfs & \\ \hline
zephyr & \\ \hline
zsensor & \\ \hline
\end{tabular}
\end{table}

While NXP's MicroPyton port offers more extensive set of supported modules, the MicroPython's 
Zephyr port offers core modules enough for many embedded applications.

\sekce{Extending Zephyr Port functionality}
\podsekce{Enabling and Disabling Modules}
This subsection aims to bring two MicroPython ports closer together in modules support by 
adding modules to the Zephyr port. This will be achieved mainly through use 
\textit{mpconfigport.h} file shown in the previous section.

As discussed in subsection \ref{zephyr_mpy_moduels} modules are added to the Zephyr port of 
MicroPython either via \textit{mpconfigport.h} or \textit{CMakeList.txt} files, which enable 
customization of the final build.

Thus, by switching some macro values in mpconfigport.h :
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 1},breaklines=true]
#define MICROPY_PY_ARRAY            (1)
#define MICROPY_PY_COLLECTIONS      (1)
#define MICROPY_PY_IO               (1)
#define MICROPY_PY_STRUCT           (1)
\end{lstlisting}
and rebuilding the port, the \textit{array, collections, io} and \textit{struct} modules 
become usable in the MicroPython's Zephyr port.

Some modules, namely \textit{deflate, framebuf, heapq, json, platform, random, re, select, uctypes, asyncio},
are not available to configuration neither in \textit{mpconfigport.h} nor 
\textit{CMakeList.txt} files. Implementations of these modules are found in \textit{/extmod} 
directory of MicroPython source code, which is meant to host non-core modules implemented in 
C. In those implementations it is possible to find macros that enable them. By adding those 
macros to the \textit{mpconfigport.h} file of Zephyr port:
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 2},breaklines=true]
#define MICROPY_PY_DEFLATE          (1)
#define MICROPY_PY_FRAMEBUF         (1)
#define MICROPY_PY_HEAPQ            (1)
#define MICROPY_PY_JSON             (1)
#define MICROPY_PY_PLATFORM         (1)
#define MICROPY_PY_RANDOM           (1)
#define MICROPY_PY_RE               (1)
#define MICROPY_PY_SELECT           (1)
#define MICROPY_PY_UCTYPES          (1)
#define MICROPY_PY_ASYNCIO          (1)
\end{lstlisting}
and rebuilding the port all the modules expect for \textit{asyncio} become available to use 
in the Zephyr port of MicroPython. The issue with \textit{asyncio} module lies in how it is 
registered in the build:
\begin{lstlisting}[caption=Asyncio module in MicroPython's Zephyr port, breaklines=true]
MP_REGISTER_MODULE(MP_QSTR__asyncio, mp_module_asyncio);
\end{lstlisting}
it's name thus is \textit{\_asyncio} and importing it by this name too makes it available in 
MicroPython's Zephyr port .

Finally, to add \textit{cmath} support a board needs to have a floating point numbers 
capabilities \cite{mpy_cmath} which FRDM-MCXN947 has. The \textit{cmath} modules is 
implemented in \textit{/py} MicroPython directory and is enabled with combination of the 
macros \textit{MICROPY\_PY\_BUILTINS\_FLOAT}, \textit{MICROPY\_PY\_CMATH} and 
\textit{MICROPY\_PY\_BUILTINS\_COMPLEX}. The last macro is already defined in the 
\textit{mpconfigport.h} file and only needs to be enabled, the first two need to be added and 
enabled:
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 3},breaklines=true]
#define MICROPY_PY_BUILTINS_FLOAT   (1)
#define MICROPY_PY_BUILTINS_COMPLEX (1)
#define MICROPY_PY_CMATH            (1)
\end{lstlisting}
and after rebuilding the Zephyr port those modules are too available in the port.

After the process of adding modules the difference in supported modules between two ports 
have narrowed and the Table \ref{tab:micropython-modules} can be updated now to show off the 
progress:

\begin{table}[H]
\centering
\caption{Difference in module support of NXP's and Zephyr MicroPython ports after adding modules to Zephyr port}
\label{tab:micropython-modules-updated}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|} \hline
\textbf{MicroPython Port to Zephyr} & \textbf{NXP's MicroPython implementation} \\ \hline
array & array \\ \hline
\_asyncio & asyncio \\ \hline
binascii & binascii \\ \hline
builtins & builtins \\ \hline
cmath & cmath \\ \hline
collections & collections \\ \hline
deflate & deflate \\ \hline
& dht \\ \hline
& ds18x20 \\ \hline
errno & errno \\ \hline
framebuf & framebuf \\ \hline
gc & gc \\ \hline
hashlib & hashlib \\ \hline
heapq & heapq \\ \hline
io & io \\ \hline
json & json \\ \hline
machine & machine \\ \hline
math & math \\ \hline
& mcx \\ \hline
micropython & micropython \\ \hline
& onewire \\ \hline
os & os \\ \hline
platform & platform \\ \hline
random & random \\ \hline
re & re \\ \hline
select & select \\ \hline
struct & struct \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\ContinuedFloat
\caption*{(continued)}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c|} \hline
\textbf{MicroPython Port to Zephyr} & \textbf{NXP's MicroPython implementation} \\ \hline
socket & \\ \hline
sys & sys \\ \hline
time & time \\ \hline
& uasyncio \\ \hline
uctypes & uctypes \\ \hline
usys & usys \\ \hline
utime & utime \\ \hline
vfs & \\ \hline
zephyr & \\ \hline
zsensor & \\ \hline
\end{tabular}
\end{table}

\podsekce{Community contributed features}
In this subsection the \textit{PWM} support will be added to the Zephyr port. Although the 
\textit{PWM} is not officially supported in the upstream repository by the Zephyr MicroPython 
port, at the time of writing, it is available as a pull request that has not yet been merged 
by the maintainer. First, the branch with the \textit{PWM} support will be downloaded and 
configured in a similar way to the previous subsection to bring support of the other modules. 
Next, an additional configuration will be made via \textit{Kconfig} to make the \textit{PWM} 
support available after building the MicroPython's Zephyr port.

First, the code with \textit{PWM} support needs to be cloned from the contributor:
\begin{lstlisting}[caption=Obtaining MicroPython's Zephyr port version with PWM support, breaklines=true]
git clone https://github.com/Ayush1325/micropython.git
\end{lstlisting}
In the cloned project \textit{Kconfig} file \textit{frdm\_mcxn947\_mcxn947\_cpu0.conf} for 
FRDM-MCXN947 configuration needs to be created in the  \textit{ports/zephyr/boards} directory 
containing :
\begin{lstlisting}[caption=Kconfig configuration for PWM support on FRDM-MCXN947 board]
CONFIG_PWM=y
CONFIG_PWM_MCUX=y
\end{lstlisting}

Both \textit{CONFIG\_PWM}\cite{zehpyr_pwm} and 
\textit{CONFIG\_PWM\_MCUX}\cite{zehpyr_pwm_mcux} are Zephyr build flags to enable 
\textit{PWM} and \textit{mcux PWM driver} respectively.

After configuration, the port with \textit{PWM} support can be build by passing to Zephyr's
\textit{west} the path to \textit{ports/zephyr/} directory of newly configured MicroPython 
version. Following the build and flash processes the \textit{PWM} functionality becomes 
enabled and can be tested via REPL environment on the \textit{pwm0} device, defined in FRDM-MCXN947 \textit{Devicetree} configuration in the Zephyr source code:
\begin{lstlisting}[caption=Testing PWM in REPL environment of the Zephyr MicroPython port, breaklines=true]
from machine import PWM
pwm = PWM(("pwm0", 0), freq=500, duty_ns=200)
print(pwm)
print(pwm.duty_ns())
\end{lstlisting}
The program outputs the defined \textit{PWM} object and the duty cycle, indicating that
the community feature was successfully added. 

\begin{literatura}

% ZEPHYR sources
\citace{zephyr1}{Zephyr Project, Introduction, 2024}{Zephyr Project, Introduction [online], 2024 Available from: https://docs.zephyrproject.org/latest/introduction/index.html}

\citace{zephyr_west}{Zephyr Project, West (Zephyr’s meta-tool), 2024}{Zephyr Project, West (Zephyr’s meta-tool) [online], 2024 Available from: https://docs.zephyrproject.org/latest/develop/west/index.html}

\citace{zephyr_kconfig}{Zephyr Project, Configuration System (Kconfig), 2022}{Zephyr Project, Configuration System (Kconfig) [online], 2022 Available from: https://docs.zephyrproject.org/latest/build/kconfig/index.html}

\citace{zephyr_mcxn947}{Zephyr Project, FRDM-MCXN947, 2025}{Zephyr Project, FRDM-MCXN947 [online], 2025 https://docs.zephyrproject.org/latest/boards/nxp/frdm\_mcxn947/doc/index.html}

\citace{zephyr_architecture}{Zephyr Project, Zephyr Security Overview, 2024}{Zephyr Project, Zephyr Security Overview [online], 2024 Available from: https://docs.zephyrproject.org/latest/security/security-overview.html}

\citace{zephyr_cmake_commands}{Zephyr Project, Additional Zephyr extension commands, 2025}{Zephyr Project, Additional Zephyr extension commands [online], 2025 Available from: https://docs.zephyrproject.org/latest/develop/west/zephyr-cmds.html}

\citace{zehpyr_west_building}{Zephyr Project, Building, Flashing and Debugging, 2024}{Zephyr Project, Building, Flashing and Debugging, [online], 2024 Available from: https://docs.zephyrproject.org/latest/develop/west/build-flash-debug.html}

\citace{zehpyr_pwm}{Zephyr Project, CONFIG\_PWM, 2023}{Zephyr Project, CONFIG\_PWM, [online], 2023 Available from: https://docs.zephyrproject.org/2.7.5/reference/kconfig/CONFIG\_PWM.html}

\citace{zehpyr_pwm_mcux}{Zephyr Project, CONFIG\_PWM\_MCUX, 2023}{Zephyr Project, CONFIG\_PWM\_MCUX, [online], 2023 Available from: https://docs.zephyrproject.org/2.7.5/reference/kconfig/CONFIG\_PWM\_MCUX.html}

% Zephyr related sources
\citace{devicetree_spec}{devicetree.org, Devicetree Specification Release v0.4, 2023}{devicetree.org, Devicetree Specification Release v0.4, 2023}

% FRDM-MCXN947 sources

\citace{mcx_manual}{NXP semiconductors, MCX Nx4x Reference Manual, 2025}{NXP semiconductors, MCX Nx4x Reference Manual, 2025 MCXNX4XRM}

\citace{mcxn947_manual}{NXP semiconductors, UM12018 FRDM-MCXN947 Board User Manual, 2024}{NXP semiconductors, UM12018 FRDM-MCXN947 Board User Manual, 2024}

\citace{mcxn947_getting_started}{NXP semiconductors, Getting Started with FRDM-MCXN947,2024}{NXP semiconductors, Getting Started with FRDM-MCXN947 [online] ,2024 Available from: https://www.nxp.com/document/guide/getting-started-with-frdm-mcxn947:GS-FRDM-MCXNXX?section=build-and-run}

\citace{mcxn947_web}{NXP semiconductors, FRDM Development Board for MCX N94/N54 MCUs , 2025}{NXP semiconductors, FRDM Development Board for MCX N94/N54 MCUs [online], 2025 Available from: https://www.nxp.com/design/design-center/development-boards-and-designs/FRDM-MCXN947}

\citace{mcxn947_mpy_bin}{NXP semiconductors, Quick start guide for MicroPython on FRDM-MCXN947 board , 2024}{NXP semiconductors, Quick start guide for MicroPython on FRDM-MCXN947 board [online], 2024 Available from: https://community.nxp.com/t5/NXP-Tech-Blog/Quick-start-guide-for-MicroPython-on-FRDM-MCXN947-board/ba-p/1799949}
% Other NXP sources 

\citace{link_server}{NXP semiconductors -- LinkServer for Microcontrollers, 2025}{NXP semiconductors, LinkServer for Microcontrollers [online], 2025 \\ Available from: https://www.nxp.com/design/design-center/software/development-software/mcuxpresso-software-and-tools-/linkserver-for-microcontrollers:LINKERSERVER}

% MicroPython sources
\citace{mpy_book}{Nicholas H. Tollervey, 2017}{\autor{Nicholas H. Tollervey} \nazev{Programming with MicroPython: embedded programming with microcontrollers and Python}. O'Reilly Media, Inc., 2017. ISBN 978-1-491-97273-1}

\citace{mpy_boards}{MicroPython, MicroPython downloads, 2025}{MicroPython, MicroPython downloads [online], 2025 Available from: https://micropython.org/download/}

\citace{mpy_cmath}{MicroPython, cmath – mathematical functions for complex numbers, 2025}{MicroPython, cmath – mathematical functions for complex numbers [online], 2025 Available from: https://docs.micropython.org/en/latest/library/cmath.html}

% Other sources
\citace{jayantilal_hc05}{Jayantilal, S. H., Interfacing of AT command based HC-05 serial Bluetooth module with minicom in Linux, 2014}{Jayantilal, S. H., Interfacing of AT command based HC-05 serial Bluetooth module with minicom in Linux, International Journal for Scientific Research and Development, 2014; 2(3): 329–332}

\citace{kernighan_c}{Kernighan, B. W., Ritchie, D. M., The C programming language, 2nd ed., 1988}{Kernighan, B. W., Ritchie, D. M., The C programming language, 2nd edition, Englewood Cliffs: Prentice Hall, 1988. ISBN 0-13-110362-8}


\citace{gnu_screen}{Free Software Foundation, GNU Screen, 2016}{Free Software Foundation, GNU Screen [online], 2016 Available from: https://www.gnu.org/software/screen/}

\end{literatura}
\end{document}