\documentclass[twoside, 12pt]{article}
\usepackage{xdipp}
\usepackage{listings}
\usepackage{caption}
\usepackage{float}
\english
\pismo{Latin Modern}


\lstdefinestyle{mystyle}{
    showspaces=false,
    tabsize=2,
    frame=single,
    basicstyle=\ttfamily\footnotesize,
}
\lstset{style=mystyle}

\begin{document}
\titul{MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947}{Dmitrii Titarenko}{Ing. Jan Kolomazník, Ph.D.}{Brno 2025}

\podekovani{I would like to express my gratitude to everyone who contributed to completion of 
this thesis.\\ I would like to thank my thesis supervisor, Ing. Jan Kolomazník, Ph.D. , for 
his guidance and support. Furthermore, I express my gratitude to Zbynek Fedra Ph.D. for 
guiding me during the creation of this thesis.\\
I am also very grateful to all the professors in the Department of Informatics at Mendel 
University for their teaching, openness, and constant support throughout my study.\\
A big thank you to family members and friends for their support and encouragement.\\
Finally, I express gratitude to the people who directly or indirectly contributed to the 
creation of this work. To those who came before me and on whose shoulders I stand.}
\prohlasenimuz{}

\abstrakt{Titarenko, D. MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947.
Bachelor thesis. Brno, 2025.}{Práce zkoumá podporu MicroPython na Zephyr RTOS s využitím 
vývojové desky FRDM-MCXN947 od NXP. Samo o sobe Zephyr RTOS poskytuje širokou podporu a 
snadno použitelné API pro mnoho embedded zařízení a jejích periferii, ale podpora MicroPython 
je stále limitovaná a nekonzistentní s MicroPython porty vyvíjený pro jíná zařízení. Práce 
analyzuje součastné limity MicroPython na Zephyr RTOS a vybírá funkčnost pro implementaci. 
Implementace zahrnuje inicializaci vývojovýho prostředí pro Zephyr a MicroPython, které bude 
upravené pro FRDM-MCXN947, provádění funkčního testování periferii vývojové desky v vývojovém 
prostředí pro Zephyr a MicroPython a porovnáním kompatibility nativného poru a Zephyr portu 
MicroPython.}
\klslova{MicroPython, závěrečná práce, Zephyr RTOS, FRDM-MCXN947}

\abstract{Titarenko, D. MicroPython Utilizing Zephyr Port and NXP FRDM-MCXN947. Bachelor 
thesis. Brno, 2025.}{This thesis explores MicroPython support on Zephyr RTOS using the NXP 
FRDM-MCXN947 development board. Zephyr RTOS itself provides extended support and easy-to-use 
APIs to many embedded devices and their peripherals, but the support of MicroPython remains 
limited and not consistent with MicroPython ports developed for other devices. This work 
analyzes the current limitations of MicroPython on Zephyr RTOS and selects specific 
functionality for implementation. The implementation involves initializing Zephyr and 
MicroPython development environments adjusted to FRDM-MCXN947, conducting functional testing 
of the development board peripherals with Zephyr and MicroPython environment, and comparing 
the compatibility of native and Zephyr ports of MicroPython.}
\keywords{MicroPython, thesis, Zephyr RTOS, FRDM-MCXN947}

\obsah

\listoffigures

\lstlistoflistings

\kapitola{Introduction}
The world of microcontrollers and embedded devices continues to grow, and such devices become 
more common with every day. Even though they are seldom noticeable we more often might find 
ourselves surrounded by them. From home appliances, to cars, to factory machines to city-wide 
networks embedded devices reach wide and deep in our lives.

But with the growing count of embedded devices grows complexity of functions they implement. 
Hence arises a need for Operating Systems(OSs) to manage sets of complex programs and provide 
a layer of abstraction to ease development in such constrain but demanding environments.

To cover demand of an Operating System in embedded devices the Zephyr Real Time Operating 
System (RTOS) was created. Zephyr RTOS is an open-source operating system with build-in 
security and optimization for resource limited devices. Zephyr kernel supports ARM, Intel 
x86, ARC, RISC-V, Nios II, Tensilica Xtensa and large number of development boards, among 
others NXPs FRDM-MCXN947. ALso Zephyr has rich API that allows developers to write high-level 
code for embedded devices.

Writing software for embedded devices is still a complex task regardless of what underlying 
technologies are used. Writing it in a language such as C adding an additional complexity
due to need of managing program memory allocation and deallocation by hand.
Leaving unhandled memory sector could lead to memory leaks or worse opens an opportunity for
an attacker to execute malicious code on an embedded device. The consequences of such problems
become much grater when occurring in the embedded world. MicroPython is an optimized subset 
of Python 3 programming language for embedded devices. It aims to ease writing software by 
managing memory using its garbage collector system, using easy to read Python-like syntax and 
providing various modules to enable work with different peripherals. Additionally, 
MicroPython allows for code portability, meaning that code written for FRDM-MCXN947
could be ported and ran on ESP32 with minimal updates to code. 

But MicroPython does not 
support every single device straightaway -- ported versions of MicroPython are submitted to 
the MicroPython repository, by a manufacturer or an enthusiasts. Later submitted port will be 
reviewed and tested by MicroPython maintainers, which is a lengthy process, for example 
MicroPython port for Zephyr was under review for 2 years.

By combining Zephyr RTOS and MicroPython in one technological stack the best of both 
technologies could be utilized. Potential exists for developers to write highly readable,
easy-to-understand and efficient code with MicroPython that make use of various hardware 
support introduced by Zephyr RTOS. Yet the state of this development environment is not yet 
firm and have plenty of rough edges and unapparent problems that could arise during the 
process of software development.

The aim of this thesis is to construct a method for configuring the development environment 
for MicroPython, Zephyr RTOS and FRDM-MCXN947 development board, provide insight of 
compatibility challenges of both platforms and propose potential solutions for extending 
MicroPython port to Zephyr RTOS. The finding of this thesis will contribute to understanding 
of the state of both platforms and their integration, informing future developers and increasing usability of MicroPython and Zephyr.

\sekce{Goal of this thesis}
Goal of the thesis is to establish development environment and workflow for developing 
applications for embedded devices with the MicroPython Zephyr port. This work could be used
in future to ease start of application development and as a reference.

\kapitola{Background}
This chapter introduces the reader to an information about Zephyr RTOS, MicroPython and FRDM-
MCXN947 board that is needed for understanding this thesis.

\sekce{Zephyr RTOS}
Zephyr is an Operation System designed for resource-constrained and embedded 
system from simple sensors to smart industrial embedded solutions with emphasis on safety. It 
supports a broad list 
of embedded devices, development boards and peripherals. Zephyr offers extensive number of 
features and services including multi-threading, inter-thread data passing, inter-thread 
synchronization, dynamic memory allocation, interrupt service, power management, networking, file system.
Zephyr project is open-source, distributed under Apache 2.0 license and was created under 
Linux Foundation organization.\cite{zephyr1}

\obrazek
\vlozobr{images/security-zephyr-system-architecture}{0.5}
\endobr{Zephyr System Architecture \obrzdroj{\cite{zephyr_architecture}}}

\podsekce{West}
West is a part of Zephyr's tool-chain used for building and configuring. West can initiate
Zephyr workspace from official upstream repository, update or change version of a local
Zephyr workspace to any version in official repository, build Zephyr application from source,
flash built application to a board.\cite{zephyr_west}

\podsekce{Kconfig}
Kconfig is Zephyr's kernel, peripheral drivers and subsystems configuration system that allow 
to configure Zephyr at a build time. Kconfig goal is to enable configuration without 
introducing changes to the source
code.

The initial board configuration can be found in \textbf{<board>\_defconfig} files. For
example configuration file for FRDM-MCXN947 is located at \textbf{boards/nxp/frdm\_mcxn947/
frdm\_mcxn947\_mcxn947\_cpu0\_defconfig}. The board configuration for NXPs' FRDM-MCXN947
is as follows:
\begin{lstlisting}[caption=FRDM-MCXN947 Kconfig configuration]
CONFIG_CONSOLE=y
CONFIG_UART_CONSOLE=y
CONFIG_SERIAL=y
CONFIG_UART_INTERRUPT_DRIVEN=y
CONFIG_GPIO=y
CONFIG_PINCTRL=y
CONFIG_ARM_MPU=y
CONFIG_HW_STACK_PROTECTION=y
CONFIG_TRUSTED_EXECUTION_SECURE=y
\end{lstlisting}

Kconfig values can be set to a \textbf{<board>\_defconfig} files, temporarily with terminal
graphical interfaces or with a \textbf{prj.conf} file at application level which overrides
the initial configuration during application build.\cite{zephyr_kconfig}

\podsekce{Devicetree}
Devicetree is a data structure to describe hardware. It is a community driven standard
that is heavily used in Zephyr project. In Zephyr devicetrees are usually build inherently 
meaning that for example FRDM-MCXN947 has a devicetree configuration \textbf{board/nxp/frdm\_mcxn947/frdm\_mcxn947\_mcxn947\_cpu0.dts}
which mainly enables peripheral devices, but includes FRDM-MCXN947 specific configuration 
from \textbf{frdm\_mcxn947.dtsi} (include file), which in turn includes 
\textbf{frdm\_mcxn947-pinctrl.dtsi} file that mostly defines pinmux groups. Additionally the 
\textbf{frdm\_mcxn947\_mcxn947\_cpu0.dts} includes \textbf{nxp\_mcxn94x.dtsi} file that 
defines memory ranges for SRAM, FLEXSPI and peripherals and includes 
\textbf{nxp\_mcxn94x\_common.dtsi} include file where most of devices including CPU, GPIO, 
CTIMER and others are defined and assigned memory ranges.\cite{devicetree_spec}

Same as Kconfig Devicetrees can be overwritten or have some specific devices configured 
differently with \textit{overlay} files, which as well needs to be placed in build directory, 
from there \textit{west} tool will use it to edit the Devicetree configuration.

\sekce{MicroPython}
MicroPython is an open-source project founded by Damien George. MicroPython is an implementation of the Python programming 
language that 
is optimized to be run on embedded and resource constraint devices. It implements 
the entire Python 3.4 syntax with some selected features from the later versions such as
\textit{async/await} from Python 3.5 , additionally on par with Python it uses garbage 
collection system for memory management. MicroPython final build include a compiler that 
compiles MicroPython code to bytecode and an runtime interpreter of the compiled bytecode.
Programs could be written directly to the MicroPython REPL(Read–eval–print loop) or be loaded
onto MicroPython host device with use of serial connection and utility programs like \textit{ampy}.


MicroPython's core development is focused on implementing and maintaining core features
of the MicroPython like Python language features, libraries, memory management and 
MicroPython interpreter. The responsibility for adapting and porting MicroPython to different
platforms lies on the community around it. Every MicroPython port introduces required 
adaptations and addresses hardware features and limitations of its platform. Consequently,
MicroPython support is not linear on all platforms, because some might lack the necessary
configuration for enabling a part of functionality or even lack reimplementation of a number of core libraries. Additionally, the slow pace of adding to source code features for various platforms 
created by the community means that
even fully functional and tested ports or features might wait for months before being reviewed.
Despite all of this, there are already many supported devices and architectures that 
MicroPython can run on. MicroPyton has additional support to be run on
operating system Zephyr RTOS and on OSes from UNIX family, as well as experimental Windows 
port.

MicroPython remains in beta-stage, hence it is a subject to possible API and code-base changes in the future.\cite{mpy_book}

\sekce{FRDM-MCXN947}
The FRDM-MCXN947 is a low-cost development board designed by NXP semiconductors. FRDM-MCXN947 
integrates Dual Arm
Cortex-M33 microcontroller, a neural processing unit, P3T1755DP I3C temperature sensor, 
TJA1057GTK/3Z CAN PHY, Ethernet PHY, SDHC circuit, RGB LED, touch pad, high-speed USB, MCU-Link debuger,
push buttons and has an option to be extended with external devices.
\cite{mcxn947_manual}

\obrazek
\vlozobr{images/frdm-diagram}{0.35}
\endobr{FRDM-MCXN947 Block diagram \obrzdroj{\cite{mcxn947_web}}}

\podsekce{Signal Multiplexing}
FRDM-MCXN947 enables use of several functions for different pins by utilizing Signal 
Multiplexing. For example pin \textbf{P0\_10} which is an red RGB pin can use \textbf{GPIO} 
functionality directly, \textbf{FLEXCOMM} by utilizing \textbf{FC0\_P6} FLEXCOMM device,
\textbf{CTIMER} by utilizing \textbf{CT0\_MAT0} CTIMER device, and \textbf{FLEXIO} 
functionality by utilizing \textbf{FLEXIO0\_D2} device.

Only one function can be used at a time on a pin and only one pin can be assigned to a 
peripheral device. \cite{mcx_manual} 

\podsekce{LinkServer}
LinkServer is an NXP command-line utility that provides  target flashing capabilities and 
firmware updates for FRDM-MCXN947. This is typically used as a backend for flashing FRDM-MCXN947 in \textit{west} utility. \cite{link_server}

\sekce{MicroPython port to Zephyr}
While Zephyr RTOS provides a feature-packed and expandable development and system to be used
in embedded world standard development in C can be time consuming. MicroPython's Zephyr port
brings advantages of both MicroPython and Zephyr to single environment, allowing to write
hight-level Python like code and rapidly prototype and debug, while also leveraging hardware 
agnostic Zephyr APIs and wide support of
different embedded devices and their peripherals.

But despite growth in support between Zephyr and MicroPython there are still features that 
lack in the port and issues with coupling of both technologies. For a long time the 
MicroPythons' Zephyr port have been using an older versions of Zephyr and
MicroPython itself. It used MicroPython 1.19.1 and Zephyr 3.1.0 versions which both came out 
in period between May and June 2022 until September 2024. In September 2022 began work by 
Maureen Helm  to introduce a CI pipeline into MicroPython repository to ease porting 
MicroPython to latest Zephyr release. From this work emerged last MicroPython Zephyr port 
version based on MicroPython 1.24.0 and Zephyr 3.7.0.

And though MicroPython Zephyr port
already supports the MicroPython modules like socket, time, math, machine and other are 
implemented and usable in the final MicroPython build they may lack support of some 
sub-modules like machine's PWM sub-module or functionality of modules and sub-modules like
not yet implemented features of machine's I2C sub-module that do not have ability to set clock and data lines.

A MicroPython's Zephyr port is built in a same way any Zephyr application is built. A 
\textit{west} utility is used and MicroPython port to Zephyr source code as a build target.
The final build could be configured and some features or peripherals could be activated or 
deactivated with \textit{Kconfig} and a final devicetree be overwritten with devicetree 
\textit{overlays}. Then the result binary file is fleshed to a target board with \textit{west}
utility.

\sekce{Summary}
For utilizing MciroPython Zephyr port on FRDM-MCXN947 board it is needed to build MicroPython 
port as a Zephyr application, and then flash this application onto the development board, 
both operations are made with use of Zephyr's \textit{west} utility. Program flashing is made using \textit{LinkServer}.

Pre-build configuration is possible using \textit{Kconfig}, for setting what peripherals and sub-system are to be enabled or disable, and \textit{Devicetree}, for creating or updating a structured description of the underling hardware.

FRDM-MCXN947 is a programmable and extendable development board with many devices, 
peripherals and systems available.

\kapitola{Methodology}
\sekce{Introduction}
This chapter introduces the reader to the set of tools used in this thesis and outlines a 
methodological approach. First Zephyr and MicroPython development environments will be setup 
and tested, following with their integration for building MicroPython's Zephyr port. Next the
MicroPython's Zephyr port will be extended with use of configuration and additional code to 
bring it  closer to the level of native port support. Finally, the thesis will conclude by 
building a web server that will run on FRDM-MCXN947  utilizing MicroPython's Zephyr port.

\sekce{Zephyr development environment setup}
This section will detail the process of setting up a development environment for working with
Zephyr RTOS. The setup will be broken into several steps to provide clear and easy-to-follow 
instructions to the reader.

Firstly, the prerequisites and dependencies would be introduced along with the installation 
process. The reader will be briefed on purpose of the key dependencies. After the 
necessary preparation the Zephyr Software Development Kit (SDK) and source code will be obtained. For the Zephyr SDK two methods for obtaining it
will be presented and discussed. Then the \textit{west} tool will be described in detail and
it's abilities for managing the project will be discussed. Next, the installation and use of 
the \textit{LinkServer} utility and its alternatives will be discussed. Finally, the 
development setup will be verified with a functional test on a FRDM-MCXN947 board and test 
prerequisites discussed.

\sekce{Use of MicroPython on FRDM-MCXN947}
This section will describe how to use MicroPython on FRDM-MCXN947 board.The 
\textit{LinkServer} utility will be used and aspects of it will be discussed.

The section will begin with an explanation on what are the possibilities to obtain 
MicroPython binary. Particularly, the current process of that takes place to obtain 
MicroPython binary working on FRDM-MCXN947 will be shown. After obtaining the binary it will 
be shown how to load it to the board. The section will conclude with a functional test of 
MicroPython possibilities.  

\sekce{MicroPython port to Zephyr RTOS}
The section will present an approach on how to setup and start using MicroPython's Zephyr 
port.

It will start with setting up a development environment for MicroPython. After this process 
of building a MicroPython Zephyr port will be shown with ways of how to influence the final 
build. The section will conclude with an illustrative program.

\sekce{Comparing native and Zephyr ports}
This section will compare two MicroPython builds the NXP native MicroPython implementation 
and Zephyr port focusing on availability and functionality of the built-in modules. The 
goal of this  section is to identify what modules are supported by each implementation and to 
highlight the missing features. In process how modules are getting added to the MicroPython's Zephyr port will be explored, which will allow to extend modules support in feature section.

\sekce{Extending Zephyr Port functionality}
This section will try to extend the MicroPython's Zephyr port with modules. 

First, list of modules available to use in MicroPython's Zephyr port will be extended by 
methods explored in previous section. Next, a community extension will be added to bring a 
PWM support and the board build will be configured with \textit{Kconfig} for PWM to work. Finally, how a new module
could be created, and how to add this module to the MicroPython build.

\sekce{Creating an HTTP server of FRDM-MCXN947 with MicroPython's Zephyr port}
In this section the process and steps to create a web server for controlling the
FRDM-MCXN947 board will be discussed. Zephyr's strong networking stack will be utilized for 
local network IP configuration as well as data transition and reception. The configuration 
process using \textit{Kconfig} and \textit{Devicetree} will be needed to enable certain 
parts of the Zephyr core libraries or to configure the hardware interface. The necessary
configuration will be explained along with the code for the server.

\kapitola{Implementation}
\sekce{Introduction}
This chapter describes configuration and development of the MicoPython's Zephyr port itself 
as of the web server built utilizing this port. The main outcome of this thesis is a MicroPython-based web server running on a FRDM-MCXN947 board that host Zephyr RTOS.

The first part of this thesis is focusing on describing the setup and a necessary 
configuration of the development environment for building and running MicroPython on Zephyr 
RTOS. Next the MicroPython port for Zephyr is compared against a MicroPython port for FRDM-
MCXN947  developed by NXP. The MicroPython's Zephyr port then is synchronized with the port 
by NXP in terms of capabilities and modules supported.

This chapter concludes with implementation of a web server that demonstraites the capabilities of the extended MicroPython's Zephyr port.

\sekce{Zephyr development environment setup}
\podsekce{Installing Zephyr and it's dependencies}
Before starting to setting up the development environment for Zephyr the needed dependencies 
need to be obtained. Those include :
\begin{itemize}
    \item \textit{git} -- Zephyr's \textit{west} tool uses \textit{git} as a backend
    \item \textit{cmake} -- Zephyr use \textit{cmake} as it's build system for configuration 
    and build files generation.
    \item \textit{ninja} -- is a performance based build system that is used by CMake for building a project.
    \item \textit{make} -- some tools expecting or fall back to Make.
    \item \textit{gperf} -- GNU utility for fast hash generation used in Zephyr for lookup. 
    \item \textit{ccache} -- an utility that speeds up compilation time by caching previous compilation.  
    \item \textit{dtc} -- compiles \textit{Devicetree} files.
    \item \textit{xz} -- is a set of data compression utilities used for decompressing Zephyr SDK.
    \item \textit{wget} -- used to download Zephyr SDK.
    \item \textit{python-pip} -- used to install Zephyr's \textit{west} tool.
    \item \textit{python-setuptools} -- Python build helper package.
    \item \textit{python-wheel} -- Python build helper package.
    \item \textit{dfu-util} -- implementation of Direct Firmware Update and is used in Zephyr to flash firmware and programs to a board. 
\end{itemize}

The next step after obtaining all the dependencies is to install the Zephyr SDK. There are
two options of installing Zephyr SDK: using the \textit{west} tool (which is shown at page \pageref{west_sdk_install}) or 
performing a manual installation. To install the SDK in desired installation directory 
execute:
\begin{lstlisting}[caption=Installing Zephyr SDK: obtaining SDK, breaklines=true]
wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.0/zephyr-sdk-0.17.0_linux-x86_64.tar.xz
wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.0/sha256.sum | shasum --check --ignore-missing
\end{lstlisting}

These commands download the archived Zephyr SDK and verify it's integrity using SHA-256 
checksum. The download \textit{URL} could be altered to download the SDK for other operating 
systems like \textit{Windows, Mac Os} by changing the system name to \textit{windows}(windows 
SDK version uses 7z archive format and does not have ARM variant) or \textit{macos} and for 
ARM processors by changing architecture name to \textit{aarch64}.

The content of the downloaded archive is the extracted file and the \textit{ setup} script is 
run. Additionally for Linux systems it is recommend to install \textit{udev} rules, which 
will allow to flash boards with Zephyr as a regular user:
\begin{lstlisting}[caption=Installing udev rules,breaklines=true]
sudo cp ~/zephyr-sdk-0.17.0/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d
sudo udevadm control --reload
\end{lstlisting}

For building and working with Zephyr applications it is required to obtain Zephyr source code 
and configure a Python virtual environment. First, Python virtual environment \textit{venv} 
needs to be installed. In the preferred working directory then the new \textit{venv} 
environment is initialized and activated:
\begin{lstlisting}[caption=Creating and activating Python venv environment]
python3 -m venv ~/zephyrproject/.venv
source ~/zephyrproject/.venv/bin/activate
\end{lstlisting}

Zephyr uses it's tool \textit{west} for to manage it's source code, dependencies and to build 
and flash applications. \textit{West} could be installed to \textit{venv} environment using:
\begin{lstlisting}[caption=Installing Zephyr's West tool]
pip install west
\end{lstlisting}

With \textit{west} installed it could be used to obtain Zephyr's source code:
\newpage
\begin{lstlisting}[caption=Obtaining Zephyr's source code]
west init
west update
\end{lstlisting}

This command registers the current Zephyr installation as a CMake config package in the CMake user package registry.\cite{zephyr_cmake_commands}
\begin{lstlisting}
west zephyr-export
\end{lstlisting}

At this point Zephyr's SDK could be installed if it was not already using \textit{west}: 
\begin{lstlisting}[caption=Installing Zephyr SDK using West]
west sdk install
\end{lstlisting}\label{west_sdk_install}

\podsekce{Installing LinkServer}
To flash application to FRDM-MCXN947 board Zephyr uses the NXP's \textit{LinkServer} utility.
The installation files for different Operating systems are available on the web page of the \textit{LinkServer} utility.\cite{link_server}

Also J-Link could be used as an alternative though it needs additional hardware peripherals.  \cite{zephyr_mcxn947}

\podsekce{Configuring serial port}
This step is not required for the development and correct work with Zephyr, but it's useful 
to have a capability to see board logs and to interact with the board through a command line 
interface from the development environment. For Linux and Mac OS \textit{minicom}\cite{jayantilal_hc05} and 
\textit{screen}\cite{gnu_screen} open-source utilities could be used, for Windows \textit{PuTTY} serial port 
capabilities could be utilized. 

For establishing serial communication with a FRDM-MCXN947 board the following configuration parameters should be used\cite{mcxn947_getting_started}:
\begin{lstlisting}[caption=Serial port configuration]
Baud rate: 115200
Data size: 8
Parity: None
Stop bit: 1
\end{lstlisting}

\podsekce{Building and flashing a program to FRDM-MCXN947}
In this subsection to carry out testing of the development environment and demonstrate the
flashing and building process of Zephyr applications, a Zephyr-provided sample program will 
be built.

To build the sample application \textit{west} utility is used:
\begin{lstlisting}[caption=Building the Blinky Program, breaklines=true]
west build -p always -b frdm_mcxn947/mcxn947/cpu0 samples/basic/blinky
\end{lstlisting}

where arguments \textit{-p always} makes a pristine build \cite{zehpyr_west_building}, 
\textit{-b frdm\_mcxn947/mcxn947/cpu0} specifies the target(\textit{cpu0} is specified 
because only it can be targeted standalone, second core is enabled after configuring 
\cite{zephyr_mcxn947}) and \textit{samples/basic/blinky} specifies program to build.

The built binary then can be flashed to the board using \textit{west} and \textit{LinkServer}. For this, board need to be connected with USB-C via \textit{J-17} port.
Flashing is run with:
\begin{lstlisting}[caption=Flashin a program]
west flash
\end{lstlisting}
After flashing, the red led will start to blink with a one-second period.

With the successful build and flashing of the program to the FRDM-MCXN947 board, it is 
verified that the Zephyr development environment functions correctly and now prepared for 
further development.

\sekce{Use of MicroPython on FRDM-MCXN947}
\podsekce{Installing MicroPython on FRDM-MCXN947}
In this section the process of installing MicroPython interpreter on FRDM-MCXN947 board is 
described.
    
    There are many boards that have direct MicroPython ports or support through their
architecture\cite{mpy_boards}, but FRDM-MCXN947 is not among them due to the port made by NXP 
developers not yet being reviewed and merged into the main MicroPython repository. Instead 
the MicroPyhton binary must be obtained through NXP's article\cite{mcxn947_mpy_bin} or 
compiled from source code of the development branch from NXP with port to FRDM-MCXN947.
For sake of time saving the MicroPython binary version used in this thesis was downloaded 
from the said NXP article.

Before proceeding with flashing the binary to the target board the \textit{LinkServer} 
utility must be installed on the host computer and the board itself is connected to the host 
computer with USB-C via \textit{J-17} port.

To ensure the board has no prior binaries install the following command is used:
\begin{lstlisting}[caption=LinkServer erase]
LinkServer flash MCXN947:FRDM-MCXN947 erase
\end{lstlisting}

To flash the binary to the FRDM-MCXN947 this command is used:
\begin{lstlisting}[caption=LinkServer flash,breaklines=true]
LinkServer flash MCXN947:FRDM-MCXN947 load firmware.bin  --addr 0
\end{lstlisting}
After the flash process has ended, serial port connection could be made to the board, which will reveal REPL environment for code execution.

\obrazek
\vlozobr{images/nxp_mpy_flash_minicom}{0.55}
\endobr{MicroPython REPL environment on the FRDM-MCXN947 board, access via the \textit{minicom} utility}

\podsekce{Writing and flashing MicroPython programs}
There are two common approaches to writing programs for MicroPython: either by entering the 
code directly to REPL, which allows fast prototyping and modules or periphery testing, or to 
load the python code onto the board using utilities like \textit{rshell} or \textit{ampy}. 

Both \textit{ampy} and \textit{rshell} utilities are installed via Python's \textit{pip} 
package manager and to the Python virtual environment.

To test MicroPython capability and program loading to the board with MicroPython the 
following code for reading temperature data from the \textit{P3T1755} temperature sensor on 
the FRDM-MCXN947 board:
\begin{lstlisting}[caption=Read tempreture data from P3T1755 sensor using MicroPython, breaklines=true]
import machine, time

P3T_ADDR = 72
i2c = machine.I2C(5, scl=machine.Pin('P1_17'), sda=machine.Pin('P1_16'))

class P3T1755:
    def __init__(self, i2c, addr):
        self.addr = addr
        self.i2c = i2c
        self.i2c.writeto(self.addr, b'\x00')

    def read(self):
        temp_raw = i2c.readfrom(self.addr, 2)
        temp_converted = ((temp_raw[0] << 4) | (temp_raw[1] >> 4)) * 0.0625
        return temp_converted

ts = P3T1755(i2c, P3T_ADDR)

while(True):
    print("Temperature: {:.2f} Deg.C".format(ts.read()))
    time.sleep_ms(100)
\end{lstlisting}

To load and run this code on the board with MicroPython the code must be saved to a file and 
loaded with:
\begin{lstlisting}[caption=Loading a program to FRDM-MCXN947 board with MicroPython using ampy utility, breaklines=true]
ampy --port /dev/ttyACM0 run you_micropython_code.py
\end{lstlisting}

The output from the board will be shown in the console the program was loaded from, to only 
load the program the \textit{--no-output} parameter could be passed to the \textit{ampy} 
utility.

\obrazek
\vlozobr{images/mpy_tempreture_test}{0.80}
\endobr{Output of the FRDM-MCXN947 board after loading temperature reading program}

It is now verified that the MicroPython port by NXP works correctly on the FRDM-MCXN947 board.


\sekce{MicroPython port to Zephyr RTOS}
\podsekce{Setup of the MicroPython Zephyr port}
This section details the process of building and running MicroPython's Zephyr port on FRDM-
MCXN947 development board. To begin firs the MicroPython source code should be obtained, 
either from \textit{git} repository or as a archived file from the project's web.

Before proceeding with the build creating a Python virtual environment in the Zephyr 
installation directory if not done yet.

The build of the MicroPython's Zephyr port is done from Zephyr development environment using \textit{west} utility:
\begin{lstlisting}[caption=Building MicroPython's Zephyr port, breaklines=true]
west build -p always -b frdm_mcxn947/mcxn947/cpu0 ~/micropython/ports/zephyr
\end{lstlisting}
Where the target program is a path to \textit{/ports/zephyr} directory in MicroPython's source
code.

During the initial build the following error may occure:
\begin{lstlisting}[caption=Error building MicroPython's Zephyr port,breaklines=true]
/micropython/ports/zephyr/modzephyr.c:52:5: error: too few arguments to function 'thread_analyzer_print'
   52 |     thread_analyzer_print();
      |     ^~~~~~~~~~~~~~~~~~~~~
\end{lstlisting}

The issue is due to an API mismatch introduced in newer versions of Zephyr. To solve this, the
Zephyr version should be lowered to 3.7.0. This could be done using \textit{git} and it's \textit{checkout} command to switch to \textit{v3.7-branch} branch.

After switching to an older branch the building process finishes without further errors and 
the resulting binary could be flashed to the FRDM-MCXN947 board using \textit{west} utility.

After flash with the help of serial port program a similar to NXP's MicroPython port REPL environment is seen with additional information on hosting OS.

\obrazek
\vlozobr{images/mpy_zephyr_build_minicom}{0.7}
\endobr{MicroPython's Zpehyr port REPL environment on the FRDM-MCXN947 board, access via the \textit{minicom} utility}

The same applies to program loading as with NXP's MicroPython port. Programs can be either 
written directly into REPL environment or uploaded using tools such as \textit{ampy}.

To verify the functionality of the built MicroPython's Zephyr port and compare it to NXP's 
port a simple program was developed, which utilizes \textit{GPIO} pins of green and red on 
board LEDs to switch between low and high voltage.

\begin{lstlisting}[caption=Led program for MicroPython's Zephyr port, breaklines=true]
import time
from machine import Pin

red = Pin(("gpio0", 10), Pin.OUT)
red.value(1)
green = Pin(("gpio0", 27), Pin.OUT)
green.value(1)

while True:
    green.value(0)
    time.sleep(1.5)
    red.value(0)
    time.sleep(1.5)
    green.value(1)
    time.sleep(1.5)
    red.value(1)
\end{lstlisting}

After loading the program to the FRDM-MCXN947 board the red and green LEDs will be periodically set to high and low voltage.

Note how the program needs to refer to a pin in the MicroPython's Zephyr port as a tuple 
while in NXP's port it uses a string name of the pin. MicroPython's Zephyr port use 
definition of the board and periphery from \textit{Devicetree} files where \textit{gpio0} is 
a peripheral which exposes various pins, such as pins 10 and 27, each configured for specific 
functions.

\sekce{Comparing native and Zephyr ports}
\podsekce{Modules available on NXP's port}
This section compares module support of NXP's and Zephyr MicroPython ports. The analysis 
includes a list of modules available for both ports. The analysis was made by importing 
modules into the REPL environment and passing them to the \textit{help()} function.

NXP port provides a variety of modules specific for the hardware of the FRDM-MCXN947 board 
and common MicroPython modules. \textit{help('modules')} command could be used to return the 
list of supported modules on NXP port:

\begin{lstlisting}[caption=NXP's port modules, breaklines=true]
__main__           asyncio/stream  gc            os        asyncio/lock
_asyncio           binascii        hashlib       platform  framebuf
_boot              builtins        heapq         random    onewire
_onewire           cmath           io            re        uctypes
array              collections     json          select
asyncio/__init__   deflate         machine       struct
asyncio/core       dht             math          sys
asyncio/event      ds18x20         mcx           time
asyncio/funcs      errno           micropython   uasyncio
\end{lstlisting}

Modules could also be passed as parameters to the \textit{help()} function to reveal what 
functions does the module have and what constants it defines.

\podsekce{Modules available on Zephyr port}\label{zephyr_mpy_moduels}
In contrast to the NXP's port, running \textit{help('modules')} does not yield the supported 
modules. Instead to get the list of supported modules it is needed to either try to import 
modules and pass them to the \textit{help()} function or to read the source-code of the 
MicroPython's Zephyr port, specifically the \textit{CMakeLists.txt CMake} file where some of 
the imported modules are listed :
\begin{lstlisting}[caption=Zephyr port CMake list, breaklines=true]
set(MICROPY_SOURCE_PORT
    main.c
    help.c
    machine_i2c.c
    machine_spi.c
    machine_pin.c
    modbluetooth_zephyr.c
    modsocket.c
    modzephyr.c
    modzsensor.c
    mphalport.c
    uart_core.c
    zephyr_device.c
    zephyr_storage.c
    mpthreadport.c
)
list(TRANSFORM MICROPY_SOURCE_PORT PREPEND ${MICROPY_PORT_DIR}/)
\end{lstlisting}

Those modules are direct ports of the equivalent Python or MicroPython modules with use of 
Zephyr APIs.

Additionally, MicroPython's Zephyr port contains \textit{prj.conf} file that is passed to 
Zephyr when compiling the port and it hav \textit{CONFIG\_MICROPY\_CONFIGFILE} parameter that
specifies a modules configuration file \textit{mpconfigport.h} :
\begin{lstlisting}[caption=Part of MicroPython's Zephyr port mpconfigport.h module conifguration file, breaklines=true]
#define MICROPY_ENABLE_GC           (1)
#define MICROPY_ENABLE_FINALISER    (MICROPY_VFS)
#define MICROPY_HELPER_REPL         (1)
#define MICROPY_REPL_AUTO_INDENT    (1)
#define MICROPY_KBD_EXCEPTION       (1)
#define MICROPY_PY_ASYNC_AWAIT      (0)
\end{lstlisting}

The \textit{mpconfigport.h} file contains a list of C macros\cite{kernighan_c} that act like 
a switch to enable and disable said modules.

An analysis yielded the following list of the supported modules in MicroPython's Zephyr port:
\begin{lstlisting}[caption=Zephyr port modules, breaklines=true]
binascii   hashlib      os      usys   zsensor  micropython
builins    machine      socket  utime  zephyr   gc
errno      math         sys     vfs    time
\end{lstlisting}

\podsekce{Comparing modules availability in two ports}
The table below summarizes the difference in module support between NXP's and Zephyr MicroPython ports:

\begin{table}[H]
\centering
\caption{Difference in module support of NXP's and Zephyr MicroPython ports}
\label{tab:micropython-modules}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c||c|c|} \hline
\textbf{Zephyr port} & \textbf{NXP port} & \textbf{Zephyr port} & \textbf{NXP port} \\ \hline
 & array &  & asyncio \\ \hline
binascii & binascii & builtins & builtins \\ \hline
 & cmath &  & collections \\ \hline
 & deflate & & dht \\ \hline
& ds18x20 & errno & errno \\ \hline
 & framebuf & gc & gc \\ \hline
hashlib & hashlib &  & heapq \\ \hline
 & io &  & json \\ \hline
machine & machine & math & math \\ \hline
& mcx & micropython & micropython \\ \hline
& onewire & os & os \\ \hline
 & platform &  & random \\ \hline
 & re &  & select \\ \hline
 & struct & socket & \\ \hline
sys & sys & time & time \\ \hline
& uasyncio &  & uctypes \\ \hline
usys & usys & utime & utime \\ \hline
vfs & & zephyr & \\ \hline
zsensor & & & \\ \hline
\end{tabular}
\end{table}

While NXP's MicroPyton port offers more extensive set of supported modules, the MicroPython's 
Zephyr port offers core modules enough for many embedded applications.

\sekce{Extending Zephyr Port functionality}
\podsekce{Enabling and Disabling Modules}
This subsection aims to bring two MicroPython ports closer together in modules support by 
adding modules to the Zephyr port. This will be achieved mainly through use 
\textit{mpconfigport.h} file shown in the previous section.

As discussed in subsection \ref{zephyr_mpy_moduels} modules are added to the Zephyr port of 
MicroPython either via \textit{mpconfigport.h} or \textit{CMakeList.txt} files, which enable 
customization of the final build.

Thus, by switching some macro values in mpconfigport.h :
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 1},breaklines=true]
#define MICROPY_PY_ARRAY            (1)
#define MICROPY_PY_COLLECTIONS      (1)
#define MICROPY_PY_IO               (1)
#define MICROPY_PY_STRUCT           (1)
\end{lstlisting}
and rebuilding the port, the \textit{array, collections, io} and \textit{struct} modules 
become usable in the MicroPython's Zephyr port.

Some modules, namely \textit{deflate, framebuf, heapq, json, platform, random, re, select, uctypes, asyncio},
are not available to configuration neither in \textit{mpconfigport.h} nor 
\textit{CMakeList.txt} files. Implementations of these modules are found in \textit{/extmod} 
directory of MicroPython source code, which is meant to host non-core modules implemented in 
C. In those implementations it is possible to find macros that enable them. By adding those 
macros to the \textit{mpconfigport.h} file of Zephyr port:
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 2},breaklines=true]
#define MICROPY_PY_DEFLATE          (1)
#define MICROPY_PY_FRAMEBUF         (1)
#define MICROPY_PY_HEAPQ            (1)
#define MICROPY_PY_JSON             (1)
#define MICROPY_PY_PLATFORM         (1)
#define MICROPY_PY_RANDOM           (1)
#define MICROPY_PY_RE               (1)
#define MICROPY_PY_SELECT           (1)
#define MICROPY_PY_UCTYPES          (1)
#define MICROPY_PY_ASYNCIO          (1)
\end{lstlisting}
and rebuilding the port all the modules expect for \textit{asyncio} become available to use 
in the Zephyr port of MicroPython. The issue with \textit{asyncio} module lies in how it is 
registered in the build:
\begin{lstlisting}[caption=Asyncio module in MicroPython's Zephyr port, breaklines=true]
MP_REGISTER_MODULE(MP_QSTR__asyncio, mp_module_asyncio);
\end{lstlisting}
it's name thus is \textit{\_asyncio} and importing it by this name too makes it available in 
MicroPython's Zephyr port .

Finally, to add \textit{cmath} support a board needs to have a floating point numbers 
capabilities \cite{mpy_cmath} which FRDM-MCXN947 has. The \textit{cmath} modules is 
implemented in \textit{/py} MicroPython directory and is enabled with combination of the 
macros \textit{MICROPY\_PY\_BUILTINS\_FLOAT}, \textit{MICROPY\_PY\_CMATH} and 
\textit{MICROPY\_PY\_BUILTINS\_COMPLEX}. The last macro is already defined in the 
\textit{mpconfigport.h} file and only needs to be enabled, the first two need to be added and 
enabled:
\begin{lstlisting}[caption={Extending Zephyr port modules support, Part 3},breaklines=true]
#define MICROPY_PY_BUILTINS_FLOAT   (1)
#define MICROPY_PY_BUILTINS_COMPLEX (1)
#define MICROPY_PY_CMATH            (1)
\end{lstlisting}
and after rebuilding the Zephyr port those modules are too available in the port.

After widening the module support on Zephyr the updated table is as follows:

\begin{table}[H]
\centering
\caption{Difference in module support of NXP's and Zephyr MicroPython ports after adding modules to Zephyr port}
\label{tab:micropython-modules-updated}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|c||c|c|} \hline
\textbf{Zephyr port} & \textbf{NXP port} & \textbf{Zephyr port} & \textbf{NXP port} \\ \hline
array & array & \_asyncio & asyncio \\ \hline
binascii & binascii & builtins & builtins \\ \hline
cmath & cmath & collections & collections \\ \hline
deflate & deflate & & dht \\ \hline
& ds18x20 & errno & errno \\ \hline
framebuf & framebuf & gc & gc \\ \hline
hashlib & hashlib & heapq & heapq \\ \hline
io & io & json & json \\ \hline
machine & machine & math & math \\ \hline
& mcx & micropython & micropython \\ \hline
& onewire & os & os \\ \hline
platform & platform & random & random \\ \hline
re & re & select & select \\ \hline
struct & struct & socket & \\ \hline
sys & sys & time & time \\ \hline
& uasyncio & uctypes & uctypes \\ \hline
usys & usys & utime & utime \\ \hline
vfs & & zephyr & \\ \hline
zsensor & & & \\ \hline
\end{tabular}
\end{table}

\podsekce{Community contributed features}
In this subsection the \textit{PWM} support will be added to the Zephyr port. Although the 
\textit{PWM} is not officially supported in the upstream repository by the Zephyr MicroPython 
port, at the time of writing, it is available as a pull request that has not yet been merged 
by the maintainer. First, the branch with the \textit{PWM} support will be downloaded and 
configured in a similar way to the previous subsection to bring support of the other modules. 
Next, an additional configuration will be made via \textit{Kconfig} to make the \textit{PWM} 
support available after building the MicroPython's Zephyr port.

First, the code with \textit{PWM} support needs to be cloned from the contributor:
\begin{lstlisting}[caption=Obtaining MicroPython's Zephyr port version with PWM support, breaklines=true]
git clone https://github.com/Ayush1325/micropython.git
\end{lstlisting}
In the cloned project \textit{Kconfig} file \textit{frdm\_mcxn947\_mcxn947\_cpu0.conf} for 
FRDM-MCXN947 configuration needs to be created in the  \textit{ports/zephyr/boards} directory 
containing :
\begin{lstlisting}[caption=Kconfig configuration for PWM support on FRDM-MCXN947 board]
CONFIG_PWM=y
CONFIG_PWM_MCUX=y
\end{lstlisting}

Both \textit{CONFIG\_PWM}\cite{zehpyr_pwm} and 
\textit{CONFIG\_PWM\_MCUX}\cite{zehpyr_pwm_mcux} are Zephyr build flags to enable 
\textit{PWM} and \textit{mcux PWM driver} respectively.

After configuration, the port with \textit{PWM} support can be build by passing to Zephyr's
\textit{west} the path to \textit{ports/zephyr/} directory of newly configured MicroPython 
version. Following the build and flash processes the \textit{PWM} functionality becomes 
enabled and can be tested via REPL environment on the \textit{pwm0} device, defined in FRDM-MCXN947 \textit{Devicetree} configuration in the Zephyr source code:
\begin{lstlisting}[caption=Testing PWM in REPL environment of the Zephyr MicroPython port, breaklines=true]
from machine import PWM
pwm = PWM(("pwm0", 0), freq=500, duty_ns=200)
print(pwm)
print(pwm.duty_ns())
\end{lstlisting}
The program outputs the defined \textit{PWM} object and the duty cycle, indicating that
the community feature was successfully added.

\podsekce{Implementing new modules}
This subsection will touch on the process of implementing completely new modules for
MicroPython's Zephyr port by creating a simple demonstrative module.

First, the macro that will enable the new module after building and flashing the MicroPython 
to FRDM-MCXN947 board is defined in the \textit{mpconfigport.h} file:
\begin{lstlisting}[caption={Implementing a new module for the Zephyr port, Part 1},breaklines=true]
#define MICROPY_NEW_MODULE           (1)
\end{lstlisting}

Next, the module file is created and added to a list of included files from the Zephyr port 
directory in the\textit{CMakeList.txt} file:
\begin{lstlisting}[caption={Implementing a new module for the Zephyr port, Part 2},breaklines=true]
set(MICROPY_SOURCE_PORT
    ...
    mod_new_mod.c
    ...
)
list(TRANSFORM MICROPY_SOURCE_PORT PREPEND ${MICROPY_PORT_DIR}/)  
\end{lstlisting}
This will add the \textit{mod\_new\_mod.c} file to a list of sources under the variable 
\textit{MICROPY\_SOURCE\_PORT} and then prepend those sources with a path to the Zephyr port 
directory from the \textit{MICROPY\_PORT\_DIR} variable. Doing so will ensure that the 
compiler can later find \textit{mod\_new\_mod.c} module file and include it in the final 
build.\cite{swidzinski_cmake}

The module implementation is as follows:
\begin{lstlisting}[caption={Implementing a new module for the Zephyr port, Part 3},breaklines=true]
#include "py/runtime.h"

#if MICROPY_NEW_MODULE

static mp_obj_t newmod_info(void) {
    mp_print_str(MP_PYTHON_PRINTER, "function that prints out information about the new module\n");
    return mp_const_none;
}
static MP_DEFINE_CONST_FUN_OBJ_0(newmod_info_obj, newmod_info);

static const mp_rom_map_elem_t newmod_module_globals_table[] = {
    { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_newmod) },
    { MP_OBJ_NEW_QSTR(MP_QSTR_newstr), MP_OBJ_NEW_QSTR(MP_QSTR_newstringvalue) },
    { MP_ROM_QSTR(MP_QSTR_info), MP_ROM_PTR(&newmod_info_obj) },
};
static MP_DEFINE_CONST_DICT(newmod_module_globals, newmod_module_globals_table);

const mp_obj_module_t newmod_module = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&newmod_module_globals,
};

MP_REGISTER_MODULE(MP_QSTR_newmod, newmod_module);

#endif
\end{lstlisting}

\textit{\#if MICROPY\_NEW\_MODULE} ensures the module is active only when enabled in 
the\textit{mpconfigport.h} file. A function \textit{newmod\_info} is defined that prints out
text to MicroPython's standard output. All module objects are listed in 
\textit{newmod\_module\_globals\_table}, where a string constant 
\textit{newstr} is also defined. The table is converted into a dictionary using 
\textit{MP\_DEFINE\_CONST\_DICT}, which is then added to the \textit{newmod\_module} object 
representing the new module. The module object is then registered as a module under the name 
\textit{newmod}.\cite{mpy_new_module}

After building and flashing the Zephyr port with the new module added, it becomes fully usable after importing.

\sekce{Creating an HTTP server of FRDM-MCXN947 with
MicroPython’s Zephyr port}
\podsekce{Introduction}
One of the objectives of the thesis was to build a lightweight implementation of HTTP server 
that can run on the FRMD-MCXN947 development board that will utilize capabilities of 
MicorPython's Zephyr port. The server provides simple web interface that could be used in 
browser and provides board interaction, specifically interaction with \textit{CTIMER} 
functionality of LED pins of the FRDM-MCXN947 board.

The implementation of the HTTP server is built on top of a custom MicroPython's Zephyr port. 
The build also includes additional hardware configuration with \textit{Devicetree} and 
Zephyr's network capabilities configuration with \textit{Kconfig}. Both configurations are 
defined in port directory and are compiled as \textit{overlay} configurations. 

\podsekce{Devicetree configuration}
This subsection describes the necessary \textit{Devicetree} configuration to enable 
\textit{PWM} output through \textit{CTIMER} function available to the pins \textit{P0\_10, P0\_27, P1\_2} via \textit{pin multiplexing} technology\cite{mcx_manual}, which is available 
on the FRDM-MCXN947 board. The \textit{Devicetree} configuration is as follows:
\begin{lstlisting}[caption={Configuring PWM support through CTIMER functionality on FRDM-MCXN947 pins P0\_10, P0\_27 and P1\_2 with Devicetree},breaklines=true]
#include <zephyr/dt-bindings/pwm/pwm.h>
#include <nxp/mcx/MCXN947VDF-pinctrl.h>
/ {
    aliases {
        red-pwm-led = &red_pwm_led;
        green-pwm-led = &gree_pwm_led;
        blue-pwm-led = &blue_pwm_led;
    };
    pwmleds {
        compatible = "pwm-leds";
        red_pwm_led: pwm_led_0 {
            pwms = <&ctimer0 0 255 PWM_POLARITY_NORMAL>;
            label = "red led pwm";
        };
        gree_pwm_led: pwm_led_1 {
            pwms = <&ctimer0 3 255 PWM_POLARITY_NORMAL>;
            label = "green led pwm";
        };

        blue_pwm_led: pwm_led_3 {
            pwms = <&ctimer1 0 255 PWM_POLARITY_NORMAL>;
            label = "green led pwm";
        };
    };
};

&ctimer0 {
    compatible = "nxp,ctimer-pwm";
    #pwm-cells = <3>;
    status = "okay";
    pinctrl-0 = <&pinmux_ctimer0_pwm_red_green>;
	pinctrl-names = "default";
};

&ctimer1 {
    compatible = "nxp,ctimer-pwm";
    #pwm-cells = <3>;
    status = "okay";
    pinctrl-0 = <&pinmux_ctimer0_pwm_blue>;
	pinctrl-names = "default";
};

&pinctrl {
    pinmux_ctimer0_pwm_red_green: pinmux_ctimer0_pwm_red_green {
        group0 {
            pinmux = <CT0_MAT0_PIO0_10>,
                <CT0_MAT3_PIO0_27>;
            slew-rate = "fast";
            drive-strength = "low";
        };
    };
    pinmux_ctimer0_pwm_blue: pinmux_ctimer0_pwm_blue {
        group0 {
            pinmux = <CT1_MAT0_PIO1_2>;
            slew-rate = "fast";
            drive-strength = "low";
        };
    };
};
\end{lstlisting}

In \textit{\&pinctrl} node, which controls \textit{pin multiplexing} and configuration 
parameters\cite{zephyr_start}, the two labels \textit{pinmux\_ctimer0\_pwm\_blue} and 
\textit{pinmux\_ctimer0\_pwm\_red\_green} are used to configure \textit{CT0\_MAT0\_PIO0\_10, 
CT0\_MAT3\_PIO0\_27} and \textit{CT1\_MAT0\_PIO1\_2} \textit{pin multiplexing functions}. 
Those functions are mapped to the hardware addresses in \textit{MCXN947VDF-pinctrl.h} file 
that is included at the top of the configuration.

The labels are then passed to the lists of pin configuration nodes \textit{pinctrl-0} in 
their corresponding peripheral nodes \textit{\&ctimer0} and \textit{\&ctimer1}. The 
peripherals \textit{ctimer0} and \textit{ctimer1} are configured to use \textit{nxp,ctimer-
pwm} driver for \textit{PWM} support. The peripherals are then enabled by being set to status \textit{okay}.

In the \textit{pwmleds} node the \textit{PWM} channels are set to the desired frequency and polarity. In \textit{aliases} node aliases are created for the pin functions.

After this configuration the MicroPython's Zephyr port built is ready to use \textit{CTIMER} function in \textit{PWM} mode for FRDM-MCXN947 pins \textit{P0\_10, P0\_27, P1\_2}.

\podsekce{Kconfig configuration}
This subsection describes the neccessary \textit{Kconfig} configuration to enable \textit{PWM} and networking use and their various components. The \textit{Kconfig} configuration is as follows:

\begin{lstlisting}[caption={Configuring PWM and networking support in MicroPython's Zephyr port with Kconfig},breaklines=true]
CONFIG_NETWORKING=y
CONFIG_NET_SOCKETS=y
CONFIG_NET_SOCKETS_POLL_MAX=4

CONFIG_NET_IPV4=y

CONFIG_NET_TCP=y

CONFIG_NET_L2_ETHERNET=y

CONFIG_PWM=y
CONFIG_PWM_MCUX=y

CONFIG_NET_BUF_FIXED_DATA_SIZE=y
CONFIG_NET_BUF_DATA_SIZE=2048 
\end{lstlisting}

The flags \textit{CONFIG\_NETWORKING, CONFIG\_NET\_SOCKETS, CONFIG\_NET\_SOCKETS\_POLL\_MAX} 
are Zephyr flags used to enable network and allow basic socket configuration. The flags 
\textit{CONFIG\_NET\_IPV4} and \textit{CONFIG\_NET\_TCP} are enabling \textit{IPv4} and 
\textit{TCP} support respectively. The \textit{CONFIG\_NET\_L2\_ETHERNET} enables 
\textit{Ethernet} support, it is needed because the board is connected to the local network
via Ethernet cable. \textit{CONFIG\_PWM} and \textit{CONFIG\_PWM\_MCUX} are for \textit{PWM}
support and to enable the right driver. The \textit{CONFIG\_NET\_BUF\_FIXED\_DATA\_SIZE} and 
\textit{CONFIG\_NET\_BUF\_DATA\_SIZE} flags are used for increasing default data buffer size 
for data transmission of the network. 

After this configuration the After this configuration the MicroPython's Zephyr port built is ready to utilize Zephyr's networking layer and have \textit{PWM} support enabled.

\podsekce{HTTP server setup}
After building and flashing new MicroPython's Zephyr port build with configuration from the
previous subsections the HTTP server can be setup on the FRDM-MCXN947 board. The 
prerequisite to running the server is to have the board connected to the local network via 
\textit{Ethernet} cable. Zephyr handles \textit{DHCP} communication with the router to 
obtain an IP address, when \textit{CONFIG\_NET\_DHCPV4} flag is 
enabled(\textit{CONFIG\_NET\_DHCPV4} is enabled in default MicroPython's Zephyr port 
\textit{Kconfig}). The server code is as follows:

\begin{lstlisting}[caption={HTTP server implementation with MicroPython for MicroPython's Zehpyr port runing on FRDM-MCXN947 board},breaklines=true]
import socket
import errno
from machine import PWM

red_pwm = PWM(("ctimer0", 0), freq=1000, duty_ns=0)
green_pwm = PWM(("ctimer0", 3), freq=1000, duty_ns=0)
blue_pwm = PWM(("ctimer1", 0), freq=1000, duty_ns=0)

CONTENT = b"""\
HTTP/1.0 200 OK
Connection: close
Content-Type: text/html

<html>
<head>
    <title>FRDM-MCXN947</title>
    <script>
        function setColor(event) {
            let color = event.target.value;
            fetch(`/set_color?hex=${encodeURIComponent(color)}`)
                .then(response => console.log(`Color set to ${color}`))
                .catch(error => console.error("Error setting color:", error));
        }

        document.addEventListener("DOMContentLoaded", function() {
            document.getElementById("colorPicker").addEventListener("input", setColor);
        });
    </script>
</head>
<body style="background-color: #333; color: #ffffff;">
    <h1>FRDM-MCXN947</h1>
    
    <input type="color" id="colorPicker">
</body>
</html>

"""
def set_color(hex_color):
    r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
    max_duty_cycle = 500_000
    r = int((r / 255) * max_duty_cycle)
    g = int((g / 255) * max_duty_cycle)
    b = int((b / 255) * max_duty_cycle)
    red_pwm.duty_ns(r)
    green_pwm.duty_ns(g)
    blue_pwm.duty_ns(b)

def main(micropython_optimize=False):
    print("starting")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    addr = ("0.0.0.0", 8080)

    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        s.bind(addr)
    except OSError as e:
        print("Error:", e.errno, errno.errorcode.get(e.errno, "Unknown Error"))
        return
    s.listen(5)
    print("Listening, connect your browser to http://<this_host>:8080/")

    while True:
        res = s.accept()
        client_sock = res[0]
        client_addr = res[1]
        print("Client address:", client_addr)
        print("Client socket:", client_sock)

        if not micropython_optimize:
            client_stream = client_sock.makefile("rwb")
        else:
            client_stream = client_sock

        print("Request:")
        req = client_stream.readline()
        print(req)

        request_line = req.decode().split()
        if len(request_line) > 1:
            path = request_line[1]
            print("request line:", request_line)
        else:
            path = "/"

        while True:
            h = client_stream.readline()
            if h == b"" or h == b"\r\n":
                break
        
        if path.startswith("/set_color"):
            hex_value = path.split("?hex=%23")[1]
            set_color(hex_value)

            client_stream.write(CONTENT)
        else:
            client_stream.write(CONTENT)

        client_stream.close()
        if not micropython_optimize:
            client_sock.close()
        print()

main()
\end{lstlisting}

First, three \textit{PWM} objects are created, each corresponding to one of the three 
\textit{CTIMER} channels for controlling red,green and blue LED lights. Each \textit{PWM} 
object is configured with a 1 kHz frequency and a duty cycle of 0 nanoseconds, which 
initially turns off the LED lights. The variable \textit{CONTENT} contains the \textit{HTML} 
code that is served to the client on connection. The \textit{HTML} has simple 
\textit{JavaScript} for sending a request back to the server. The \textit{set\_color} 
function parses \textit{HEX} color string and updates each \textit{PWM} light with a
corresponding configuration to give an appearance of the right color. The \textit{main} 
function establishes \textit{TCP} socket on port 8080 and listens for an incoming
connection. When the client client establishes connection, the server reads the request. If
the path begins with \textit{/set\_color}, the server reads the hexadecimal color of the
query string and passes it to the \textit{set\_color} function to set the color of LED 
lights. After reconfiguring \textit{PWM} objects or when the client request does not have 
\textit{/set\_color} string in the path, the server serves the \textit{HTML} content.

\podsekce{Running the server on FRMD-MCXN947}
First connect the FRDM-MCXN947 board to the host PC and to the local network via Ethernet as shown:
\newpage
\obrazek
\vlozobr{images/connected_board}{0.2}
\endobr{FRDM-MCXN947 board correctly connected to the host PC and with Ethernet cable}

Load the right firmware with \textit{PWM} support and correct configuration to the board with:
\begin{lstlisting}[caption=Load the MicroPython's Zephyr Port with PWM support to the FRDM-MCXN947]
LinkServer flash MCXN947:FRDM-MCXN947 load zephyr.bin --addr 0
\end{lstlisting}

Or rebuild and flash it with:
\begin{lstlisting}[caption=Build and flash the MicroPython's Zephyr Port with PWM support to the FRDM-MCXN947, breaklines=true]
west build -p always -b frdm_mcxn947/mcxn947/cpu0 micropython/ports/zephyr/
west flash
\end{lstlisting}

Next load the board with the HTTP server program:
\begin{lstlisting}[caption=Loading HTTP server to the FRDM-MCXN947 board]
ampy --port /dev/ttyACM0 run http_server.py
\end{lstlisting}
The device file might be different from \textit{/dev/ttyACM0} on other systems.

Connecting to the server requires devices' IP address. It could be obtained via the home network router interface or with the help of a network utility such as \textit{ arp-scan}.

After connecting to the FRDM-MCXN947 IP address on port 8080 the web page is served:
\newpage
\obrazek
\vlozobr{images/web_page}{0.6}
\endobr{Web page served on connection to FRDM-MCXN947}

From there the device could be controlled and on color change it will receive and respond to 
the request. At this stage connecting to the board with serial port will reveal connection logs:

\obrazek
\vlozobr{images/server_logs}{0.8}
\endobr{HTTPS server request logs}

\kapitola{Discussion}
While the MicroPython's Zephyr port might still require some improvements, it is already
demonstrates advantages over vendor-specific ports.

The biggest advantage of using the Zephyr 
port over vendor-specific one, like NXP's implementation of MicroPython, is it's ability to 
work on any Zephyr supported device. For developers it means that instead of costly re-
implementation of MicroPython to the new platform, it is possible to utilize the Zephyr port
saving time that could be invested in precise configuration and implementation of the new
capabilities yet missing from the port implementation. 

Next advantage of the MicroPython's Zephyr port is its modularity and an option to utilize 
advanced configuration. With vendor-specific ports developers are getting preconfigured 
implementation that is tuned usually for use on one board. With Zephyr port peripherals could 
be configured differently depending on the need of specific program, some modules and 
capabilities could be enabled or disabled entirely, therefore for example reducing the size of 
final program.

Another notable advantage of the Zephyr port is community collaboration and code 
maintainability. Implementation of some module or peripheral support could be shared by 
different devices and therefore reduce code duplication and speed up application development.

Finally, as the Zephyr RTOS matures and better drivers and new technologies are introduced the 
MicroPython's Zephyr port would become the direct beneficiary of this development. Future 
enchantments could include utilization of better drivers and extension of the existing 
peripheral support, for example \textit{I2C} or \textit{I3C} support introduction to the port, introduction of a module highlighting current configuration of the port or even a configuration via REPL environment.

\kapitola{Conclusion}
The implementation phase of this thesis began with the necessary setup and configuration of
the Zephyr development environment and its key dependencies, \textit{LinkServer} utility to
enable firmware flashing to the FRDM-MCXN947 development board, and of a serial port utility
to enable output observation and direct programming of the board in REPL environment.
Correct functionality of the installed Zephyr development environment was tested by loading
sample program and evaluated its correct work.

Following this MicroPython implementation by NXP made specifically for FRMD-MCXN947 board was
obtained, flashed to the board. Capabilities of the MicroPython implementation by NXP were
tested by loading to the board and evaluated the behavior of a sample program.

The core part of the implementation chapter focused on creation of the
MicroPython's Zephyr port that would utilize powerful Zephyr APIs but retain ease of use of
MicroPython. The two implementations were then compared against one another in terms of module
support. The comparison yielded the conclusion that NXP's MicroPython implementation had a
list of supported modules larger than MicroPython's Zephyr port, those findings were presented
in form of a table. Then the Zephyr port was configured and some missing modules were added to
the port thus also illustrating the port flexibility and its ability to be highly modular.
The updated MicroPython's Zephyr port was then compared against NXP's MicroPython 
implementation in terms of module support, the comparison showed a significant improvement for
MicroPython's Zephyr port.

The MicroPython's Zephyr port was further enhanced by introducing \textit{PWM} support made by
efforts of the MicroPython community. Additionally, the potential for adding custom modules
were show further highlighting ports flexibility.

The practicality of the port was shown by implementing and running an HTTP server. Preceding
to running the server the port was further configured with \textit{Kconfig} to add Zephyr's
comprehensive network support and with \textit{Devicetree} to correctly configure \textit{PWM}
use on the FRDM-MCXN947 board.

The final state of this thesis fulfills the goals defined for it. During the development
process additional module and hardware support was added thus expanding the MicroPython's
Zephyr port. The thesis might also serve as a foundation for other developers and creation of further related theses.

\begin{literatura}
% ZEPHYR sources
\citace{zephyr1}{Zephyr Project, Introduction, 2024}{Zephyr Project, Introduction [online], 2024 Available from: https://docs.zephyrproject.org/latest/introduction/index.html}

\citace{zephyr_west}{Zephyr Project, West (Zephyr’s meta-tool), 2024}{Zephyr Project, West (Zephyr’s meta-tool) [online], 2024 Available from: https://docs.zephyrproject.org/latest/develop/west/index.html}

\citace{zephyr_kconfig}{Zephyr Project, Configuration System (Kconfig), 2022}{Zephyr Project, Configuration System (Kconfig) [online], 2022 Available from: https://docs.zephyrproject.org/latest/build/kconfig/index.html}

\citace{zephyr_mcxn947}{Zephyr Project, FRDM-MCXN947, 2025}{Zephyr Project, FRDM-MCXN947 [online], 2025 https://docs.zephyrproject.org/latest/boards/nxp/frdm\_mcxn947/doc/index.html}

\citace{zephyr_architecture}{Zephyr Project, Zephyr Security Overview, 2024}{Zephyr Project, Zephyr Security Overview [online], 2024 Available from: https://docs.zephyrproject.org/latest/security/security-overview.html}

\citace{zephyr_cmake_commands}{Zephyr Project, Additional Zephyr extension commands, 2025}{Zephyr Project, Additional Zephyr extension commands [online], 2025 Available from: https://docs.zephyrproject.org/latest/develop/west/zephyr-cmds.html}

\citace{zehpyr_west_building}{Zephyr Project, Building, Flashing and Debugging, 2024}{Zephyr Project, Building, Flashing and Debugging, [online], 2024 Available from: https://docs.zephyrproject.org/latest/develop/west/build-flash-debug.html}

\citace{zehpyr_pwm}{Zephyr Project, CONFIG\_PWM, 2023}{Zephyr Project, CONFIG\_PWM, [online], 2023 Available from: https://docs.zephyrproject.org/2.7.5/reference/kconfig/CONFIG\_PWM.html}

\citace{zehpyr_pwm_mcux}{Zephyr Project, CONFIG\_PWM\_MCUX, 2023}{Zephyr Project, CONFIG\_PWM\_MCUX, [online], 2023 Available from: https://docs.zephyrproject.org/2.7.5/reference/kconfig/CONFIG\_PWM\_MCUX.html}

% Zephyr related sources
\citace{devicetree_spec}{devicetree.org, Devicetree Specification Release v0.4, 2023}{devicetree.org, Devicetree Specification Release v0.4, 2023}

\citace{zephyr_start}{Ramírez-Sánchez, Earl O., A Practical Start with Zephyr RTOS, 2024}{Ramírez-Sánchez, Earl O., A Practical Start with Zephyr RTOS, 2024}


% FRDM-MCXN947 sources

\citace{mcx_manual}{NXP semiconductors, MCX Nx4x Reference Manual, 2025}{NXP semiconductors, MCX Nx4x Reference Manual, 2025 MCXNX4XRM}

\citace{mcxn947_manual}{NXP semiconductors, UM12018 FRDM-MCXN947 Board User Manual, 2024}{NXP semiconductors, UM12018 FRDM-MCXN947 Board User Manual, 2024}

\citace{mcxn947_getting_started}{NXP semiconductors, Getting Started with FRDM-MCXN947,2024}{NXP semiconductors, Getting Started with FRDM-MCXN947 [online] ,2024 Available from: https://www.nxp.com/document/guide/getting-started-with-frdm-mcxn947:GS-FRDM-MCXNXX?section=build-and-run}

\citace{mcxn947_web}{NXP semiconductors, FRDM Development Board for MCX N94/N54 MCUs , 2025}{NXP semiconductors, FRDM Development Board for MCX N94/N54 MCUs [online], 2025 Available from: https://www.nxp.com/design/design-center/development-boards-and-designs/FRDM-MCXN947}

\citace{mcxn947_mpy_bin}{NXP semiconductors, Quick start guide for MicroPython on FRDM-MCXN947 board , 2024}{NXP semiconductors, Quick start guide for MicroPython on FRDM-MCXN947 board [online], 2024 Available from: https://community.nxp.com/t5/NXP-Tech-Blog/Quick-start-guide-for-MicroPython-on-FRDM-MCXN947-board/ba-p/1799949}
% Other NXP sources 

\citace{link_server}{NXP semiconductors -- LinkServer for Microcontrollers, 2025}{NXP semiconductors, LinkServer for Microcontrollers [online], 2025 \\ Available from: https://www.nxp.com/design/design-center/software/development-software/mcuxpresso-software-and-tools-/linkserver-for-microcontrollers:LINKERSERVER}

% MicroPython sources
\citace{mpy_book}{Nicholas H. Tollervey, 2017}{\autor{Nicholas H. Tollervey} \nazev{Programming with MicroPython: embedded programming with microcontrollers and Python}. O'Reilly Media, Inc., 2017. ISBN 978-1-491-97273-1}

\citace{mpy_boards}{MicroPython, MicroPython downloads, 2025}{MicroPython, MicroPython downloads [online], 2025 Available from: https://micropython.org/download/}

\citace{mpy_cmath}{MicroPython, cmath – mathematical functions for complex numbers, 2025}{MicroPython, cmath – mathematical functions for complex numbers [online], 2025 Available from: https://docs.micropython.org/en/latest/library/cmath.html}

\citace{mpy_new_module}{MicroPython, Implementing a Module, 2025}{MicroPython, Implementing a Module [online], 2025 Available from: https://docs.micropython.org/en/latest/develop/library.html}

% Other sources
\citace{jayantilal_hc05}{Jayantilal, S. H., Interfacing of AT command based HC-05 serial Bluetooth module with minicom in Linux, 2014}{Jayantilal, S. H., Interfacing of AT command based HC-05 serial Bluetooth module with minicom in Linux, International Journal for Scientific Research and Development, 2014; 2(3): 329–332}

\citace{kernighan_c}{Kernighan, B. W., Ritchie, D. M., The C programming language, 2nd ed., 1988}{Kernighan, B. W., Ritchie, D. M., The C programming language, 2nd edition, Englewood Cliffs: Prentice Hall, 1988. ISBN 0-13-110362-8}

\citace{swidzinski_cmake}{Swidzinski, R., Modern CMake for C++, 2022}{Swidzinski, R., Modern CMake for C++: Discover a better approach to building, testing, and packaging your software, Birmingham: Packt Publishing Ltd, 2022. ISBN 9781803239729}


\citace{gnu_screen}{Free Software Foundation, GNU Screen, 2016}{Free Software Foundation, GNU Screen [online], 2016 Available from: https://www.gnu.org/software/screen/}

\end{literatura}
\end{document}